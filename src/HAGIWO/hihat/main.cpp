/*
HAGIWO MOD2 HiHat Ver1.0
white and blue noise base HiHat.

--Pin assign---
POT1     A0       Decay time
POT2     A1       Deacy curve
POT3     A2       BPF freq
IN1      GPIO7    Trig in
IN2      GPIO0    Accent (Volume decreases when HIGH)
CV       A2       Shared with POT3
OUT      GPIO1    Audio output
BUTTON   GPIO6    Change noise source (white or blue)
LED      GPIO5    Trig in
EEPROM    N/A


CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>

/********************  === Core constants ===  *******************************************/
const float    SYS_CLOCK = 150000000.0f;      // 150 MHz
const float    AUDIO_FS  = SYS_CLOCK / 4096;  // ≒36.6 kHz
const uint32_t TABLE_SZ  = 30000;             // Length of noise table

const float    PWM_FS    = 1023.0f;           // 10‑bit full‑scale
const float    PWM_MID   = PWM_FS / 2.0f;     // 511
const float    AMP_SCALE = 3.5f;              // Base gain
const float    MASTER_ATTEN = 0.8f;           // −1.9 dB master attenuation

const uint16_t FADE_IN_SMP  = 73;             // ≒2 ms
const uint16_t FADE_OUT_SMP = 40;             // ≒1 ms
const uint32_t LED_DURATION_US = 10000;       // LED on‑time 10 ms

/********************  === ADC ===  ******************************************************/
const uint8_t  ADC_RES_BITS = 10;
const uint16_t ADC_MAX_VAL  = (1 << ADC_RES_BITS) - 1;

/********************  === Buffers ===  **************************************************/
float   noiseTbl[TABLE_SZ];     // Noise table
int16_t outHH[TABLE_SZ];        // Output waveform buffer

/********************  === Playback state / control ===  *********************************/
volatile bool     playingHH   = false;
volatile uint32_t idxHH       = 0;

volatile float decayBase  = 5.0f;
volatile float decayCurve = 1.0f;
volatile float fc         = 500.0f;

volatile bool  reqTrig         = false;
volatile float volFactor       = 1.0f;

// --- Noise mode switching ---
volatile uint8_t noiseMode      = 0;   // 0:Blue / 1:White
volatile bool    reqNoiseUpdate = false;

volatile uint32_t ledOffUs = 0;

uint sliceAudio, sliceIRQ;

/********************  === Helpers ===  **************************************************/
inline uint16_t readADC(uint8_t pin){ return analogRead(pin); }

/********************  === Noise generation ===  ****************************************/
// Blue noise
void generateBlueNoise(){
  float prev = 2.0f*(rand()/(float)RAND_MAX) - 1.0f;
  noiseTbl[0] = prev * 0.5f;
  for(uint32_t i=1;i<TABLE_SZ;++i){
    float w = 2.0f*(rand()/(float)RAND_MAX) - 1.0f;
    float b = (w - prev) * 0.5f;  prev = w;
    noiseTbl[i] = constrain(b, -1.0f, 1.0f);
  }
}
// White noise
void generateWhiteNoise(){
  for(uint32_t i=0;i<TABLE_SZ;++i)
    noiseTbl[i] = 2.0f*(rand()/(float)RAND_MAX) - 1.0f;
}
// Update table
void updateNoiseTable(){
  if(noiseMode==0) generateBlueNoise();
  else             generateWhiteNoise();
}

/********************  === Voice generation ===  ****************************************/
void buildVoice(int16_t* dst,float decayB,float curve,float fcC){
  const float Q = 0.8f;
  float w0 = 2.0f*PI*fcC/AUDIO_FS;
  float sw = sinf(w0), cw = cosf(w0);
  float alpha = sw/(2.0f*Q);
  float b0 =  Q*alpha, b1 = 0.0f,      b2 = -Q*alpha;
  float a0 = 1.0f+alpha, a1 = -2.0f*cw, a2 = 1.0f-alpha;
  float ia0 = 1.0f/a0;
  b0*=ia0; b1*=ia0; b2*=ia0; a1*=ia0; a2*=ia0;

  float x1=0,x2=0,y1=0,y2=0, env=1.0f;
  float expK = expf(-decayB*curve/TABLE_SZ);

  for(uint32_t i=0;i<TABLE_SZ;++i){
    float x0 = noiseTbl[i]*env;
    float y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;
    x2=x1; x1=x0; y2=y1; y1=y0;

    float fade = 1.2f;
    if(i<FADE_IN_SMP)                  fade = i/float(FADE_IN_SMP);             // Fade‑in
    else if(i>TABLE_SZ-FADE_OUT_SMP-1) fade = (TABLE_SZ-i-1)/float(FADE_OUT_SMP); // Fade‑out
    y0 *= fade;

    dst[i] = int16_t(constrain(y0,-1.0f,1.0f)*PWM_MID*MASTER_ATTEN);
    env *= expK;
  }
}

/********************  === PWM IRQ ===  **************************************************/
void on_pwm_wrap(){
  pwm_clear_irq(sliceIRQ);
  int32_t mix = 0;
  if(playingHH){
    mix += outHH[idxHH++];
    if(idxHH>=TABLE_SZ){ playingHH=false; idxHH=0; }
  }
  int32_t val = PWM_MID + int32_t(mix*AMP_SCALE*volFactor);
  if(val<0) val=0; else if(val>1023) val=1023;
  pwm_set_chan_level(sliceAudio,PWM_CHAN_B,uint16_t(val));
}

/********************  === ISRs ===  *****************************************************/
// Trigger input ISR
void triggerISR(){
  volFactor = digitalRead(0) ? 0.5f : 1.0f; // Volume switch
  reqTrig = true;
  digitalWrite(5,HIGH);
  ledOffUs = micros() + LED_DURATION_US;
}
// Noise‑select button ISR
void noiseButtonISR(){
  noiseMode ^= 1;           // Toggle 0 ↔ 1
  reqNoiseUpdate = true;
}

/********************  === SETUP ===  ****************************************************/
void setup(){
  analogReadResolution(ADC_RES_BITS);
  randomSeed(analogRead(26));
  updateNoiseTable();

  pinMode(1,OUTPUT); gpio_set_function(1,GPIO_FUNC_PWM); sliceAudio=pwm_gpio_to_slice_num(1);
  pinMode(2,OUTPUT); gpio_set_function(2,GPIO_FUNC_PWM); sliceIRQ  =pwm_gpio_to_slice_num(2);
  pwm_set_clkdiv(sliceAudio,1); pwm_set_wrap(sliceAudio,1023); pwm_set_enabled(sliceAudio,true);
  pwm_set_clkdiv(sliceIRQ,1);   pwm_set_wrap(sliceIRQ,4095);  pwm_set_enabled(sliceIRQ,true);
  pwm_clear_irq(sliceIRQ); pwm_set_irq_enabled(sliceIRQ,true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP,on_pwm_wrap); irq_set_enabled(PWM_IRQ_WRAP,true);

  pinMode(0,INPUT);
  pinMode(5,OUTPUT); digitalWrite(5,LOW);
  pinMode(7,INPUT); attachInterrupt(digitalPinToInterrupt(7),triggerISR,RISING);
  pinMode(6,INPUT_PULLUP); attachInterrupt(digitalPinToInterrupt(6),noiseButtonISR,FALLING);
}

/********************  === LOOP ===  *****************************************************/
void loop(){
  if(ledOffUs && micros() >= ledOffUs){ digitalWrite(5,LOW); ledOffUs=0; }

  float norm0 = 1.0f - (readADC(A0)/float(ADC_MAX_VAL));
  float norm1 = 1.0f - (readADC(A1)/float(ADC_MAX_VAL));
  float norm2 = 1.0f - (readADC(A2)/float(ADC_MAX_VAL));

  decayBase  = 0.1f +  9.0f * norm0;
  decayCurve = 0.2f +  5.0f * norm1;
  fc         = 100.0f + 15900.0f * norm2;

  if(reqNoiseUpdate){ reqNoiseUpdate=false; updateNoiseTable(); }

  if(reqTrig){
    reqTrig=false;
    buildVoice(outHH,decayBase,decayCurve,fc);
    idxHH=0; playingHH=true;
  }
  delayMicroseconds(500);   // ≒1 kHz main loop rate
}
