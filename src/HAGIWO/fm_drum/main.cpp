/*
HAGIWO MOD2 FM Drum Ver1.2

Two‑operator FM percussion voice for Eurorack.
— 3 potentiometers × 2 modes  →  6 parameters
— Accent input (GPIO0) cuts level by −6 dB when HIGH
— Wavetable synthesis; 4 096 samples per note
— Click‑free edges: 2 % cosine fade‑in / 10 % fade‑out
— All parameters stored in on‑board flash (EEPROM emulation)

--Pin assign---
POT1     A0       Mode0: Pitch               | Mode1: Decay Time
POT2     A1       Mode0: Operator Ratio      | Mode1: Ratio Envelope
POT3     A2       Mode0: Modulation Index    | Mode1: Modulation Index 
IN1      GPIO7    Trig in
IN2      GPIO0    Accent  – level × 0.5 when HIGH
CV       A2       Shared with POT3
OUT      GPIO1    Audio PWM output (10‑bit)
BUTTON   GPIO6    Mode toggle & parameter save
LED      GPIO5    Mode indicator (ON = Mode 1)
EEPROM   save 6 parameter

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.2  - Add: Store select mode in EEPROM
v1.1  - Fix: EEPROM-related malfunction
v1.0  - Init: Initial release
*/

#include <Arduino.h>
#include "hardware/pwm.h"  // RP2040 hardware PWM register access
#include "hardware/irq.h"  // IRQ helpers
#include <math.h>
#include <EEPROM.h>  // on‑flash key/value storage

constexpr int TABLE_SIZE = 4096;                      // wavetable length
constexpr int TABLE_MASK = TABLE_SIZE - 1;            // for cheap modulo
constexpr float TABLE_INV = 1.0f / (TABLE_SIZE - 1);  // 1/(N‑1) pre‑calc

const float SYS_CLOCK = 150'000'000.0f;                                  // RP2040 core clock (Hz)
const float NOTE_LEN = 0.3f;                                             // fixed note duration (s)
const float BASE_INC = (TABLE_SIZE * 4096.0f) / (NOTE_LEN * SYS_CLOCK);  // phase step per PWM tick
const float DT = NOTE_LEN / TABLE_SIZE;                                  // time per sample
const float FULL_SCALE = 1023.0f;                                        // 10‑bit PWM range
const float MID_LEVEL = FULL_SCALE / 2.0f;                               // mid‑rail => silence

bool editMode = false;  // false: Mode0, true: Mode1

// Real‑time parameters
volatile float f0 = 200.0f;       // fundamental (Hz)
volatile float opRatio = 2.0f;    // operator frequency ratio
volatile float modIndex = 1.0f;   // modulation index (1 … 10)
volatile float decayRate = 5.0f;  // amplitude decay rate
volatile float ratioEnv = 0.0f;   // ratio envelope depth
volatile float indexEnv = 0.3f;   // index envelope depth (fixed)

// Accent flag — updated on every trigger edge
volatile bool accentState = false;  // true = level × 0.5

// Playback state variables
volatile bool noteOn = false;     // true while table is streamed
volatile float phase = 0.0f;      // fractional table index
volatile float softClipK = 1.0f;  // tanh drive constant (= modIndex)

// Wavetable buffers
uint16_t rawTable[TABLE_SIZE];    // pure FM signal (0‑FULL_SCALE)
uint16_t finalTable[TABLE_SIZE];  // clipped & tapered copy streamed by PWM

// PWM slices
uint sliceAudio;  // GPIO1 – PWM channel B → audio
uint sliceTimer;  // GPIO2 – dummy PWM used only for IRQ timing

// PWM wrap interrupt (audio ISR)
void on_pwm_wrap() {
  pwm_clear_irq(sliceTimer);  // acknowledge IRQ

  if (!noteOn) {  // idle → output mid‑rail
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
    return;
  }

  // Linear interpolation between table samples
  float idx = phase;
  uint32_t i = (uint32_t)idx;
  float frac = idx - i;
  uint16_t s1 = finalTable[i];
  uint16_t s2 = finalTable[(i + 1) & TABLE_MASK];
  float y = s1 * (1.0f - frac) + s2 * frac;
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)y);

  // advance phase; stop after one table pass
  phase += BASE_INC;
  if (phase >= (float)TABLE_SIZE) {
    noteOn = false;
    phase = 0.0f;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
  }
}

// FM wavetable generation
void make_wavetable() {
  float phaseC = 0.0f;
  float phaseM = 0.0f;
  const float twoPi = 2.0f * PI;
  const float stepC = twoPi * f0 * DT;  // carrier increment

  for (int i = 0; i < TABLE_SIZE; ++i) {
    float x = i * TABLE_INV;           // 0 … 1 across table
    float envR = 1.0f - ratioEnv * x;  // ratio envelope
    float envI = 1.0f - indexEnv * x;  // index envelope

    float stepM = twoPi * f0 * (opRatio * envR) * DT;  // modulator inc
    phaseM += stepM;
    phaseC += stepC;

    float sample = sinf(phaseC + (modIndex * envI) * sinf(phaseM));
    rawTable[i] = (uint16_t)((sample + 1.0f) * (FULL_SCALE / 2.0f));
  }
}

void setup() {
  // restore parameters from flash
  EEPROM.begin(64);
  { float t; EEPROM.get(0, t);  f0 = t; }
  { float t; EEPROM.get(4, t);  opRatio = t; }
  { float t; EEPROM.get(8, t);  modIndex = t; if (modIndex < 1.0f) modIndex = 1.0f; }
  softClipK = modIndex;
  { float t; EEPROM.get(12, t); decayRate = t; }
  { float t; EEPROM.get(16, t); ratioEnv = t; }
  { bool u;  EEPROM.get(20, u); editMode = !u; }

  make_wavetable();
  memcpy(finalTable, rawTable, sizeof(rawTable));

  // PWM setup
  pinMode(1, OUTPUT); gpio_set_function(1, GPIO_FUNC_PWM);  // audio PWM
  pinMode(2, OUTPUT); gpio_set_function(2, GPIO_FUNC_PWM);  // timer PWM
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceTimer = pwm_gpio_to_slice_num(2);
  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, 1023);
  pwm_set_enabled(sliceAudio, true);
  pwm_set_clkdiv(sliceTimer, 1);
  pwm_set_wrap(sliceTimer, 4095);
  pwm_set_enabled(sliceTimer, true);
  pwm_clear_irq(sliceTimer);
  pwm_set_irq_enabled(sliceTimer, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  // GPIO setup
  pinMode(7, INPUT);         // trigger input
  pinMode(0, INPUT);         // accent input (active HIGH)
  pinMode(6, INPUT_PULLUP);  // mode button
  pinMode(5, OUTPUT);        // mode LED

  // attach trigger ISR
  attachInterrupt(
    digitalPinToInterrupt(7), []() {
      noteOn = true;
      phase = 0.0f;
      accentState = digitalRead(0);  // sample accent pin

      // protect against audio ISR while rebuilding tables
      irq_set_enabled(PWM_IRQ_WRAP, false);
      make_wavetable();

      // envelope & final‑table post‑process
      const int fadeInEnd = (int)(TABLE_SIZE * 0.02f);     // 2 % head ramp
      const int fadeOutStart = (int)(TABLE_SIZE * 0.90f);  // 10 % tail ramp
      const int fadeOutDen = TABLE_SIZE - 1 - fadeOutStart;
      const float invN = 1.0f / (TABLE_SIZE - 1);
      const float expStep = expf(-decayRate * invN);
      const float halfScale = FULL_SCALE / 2.0f;
      const float invHalfScale = 2.0f / FULL_SCALE;
      const float clipNorm = 1.0f / tanhf(softClipK);
      const float level = accentState ? 0.5f : 1.0f;  // −6 dB accent

      float env = 1.0f;
      for (int i = 0; i < TABLE_SIZE; ++i) {
        float bipolar = (rawTable[i] - MID_LEVEL) * invHalfScale;
        float clipped = tanhf(softClipK * bipolar * env) * clipNorm;
        clipped *= level;  // apply accent
        float y = clipped * halfScale + MID_LEVEL;

        // fade‑in (first 2 %)
        if (i < fadeInEnd) {
          float mu = (float)i / fadeInEnd;
          float mu2 = (1.0f - cosf(mu * PI)) * 0.5f;
          y = (1.0f - mu2) * MID_LEVEL + mu2 * y;
        }
        // fade‑out (last 10 %)
        else if (i >= fadeOutStart) {
          float mu = (float)(i - fadeOutStart) / fadeOutDen;
          float mu2 = (1.0f - cosf(mu * PI)) * 0.5f;
          y = (1.0f - mu2) * y + mu2 * MID_LEVEL;
        }
        finalTable[i] = (uint16_t)y;
        env *= expStep;
      }
      irq_set_enabled(PWM_IRQ_WRAP, true);  // resume audio ISR
    },
    RISING);
}

// Main loop (UI)
void loop() {
  static bool prevBtn = HIGH;
  bool currBtn = digitalRead(6);

  // handle button press
  if (prevBtn == HIGH && currBtn == LOW) {
    editMode = !editMode;       // toggle mode
    digitalWrite(5, editMode);  // LED reflects current mode

    { float t = f0;       EEPROM.put(0,  t); }
    { float t = opRatio;  EEPROM.put(4,  t); }
    { float t = modIndex; EEPROM.put(8,  t); }
    { float t = decayRate;EEPROM.put(12, t); }
    { float t = ratioEnv; EEPROM.put(16, t); }
    { bool  u = editMode; EEPROM.put(20, u); }
    EEPROM.commit();
  }
  prevBtn = currBtn;

  // read potentiometers
  if (!editMode) {  //  Mode 0 : Pitch / Ratio / Index
    int a0 = analogRead(A0);
    f0 = 30.0f + 1170.0f * (a0 / 1023.0f);

    int a1 = analogRead(A1);
    opRatio = 0.5f + 7.5f * (a1 / 1023.0f);

    int a2 = analogRead(A2);
    modIndex = 1.0f + 9.0f * ((1023 - a2) / 1023.0f);
    softClipK = modIndex;

  } else {  //  Mode 1 : Decay / RatioEnv / Index
    int a0 = analogRead(A0);
    decayRate = 0.5f + 9.5f * ((1023 - a0) / 1023.0f);

    int a1 = analogRead(A1);
    ratioEnv = 1.0f - (a1 / 1023.0f);

    int a2 = analogRead(A2);
    modIndex = 1.0f + 9.0f * ((1023 - a2) / 1023.0f);
    softClipK = modIndex;
  }

  delay(10);  // simple UI debounce / CPU breather
}
