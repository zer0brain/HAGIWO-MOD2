/*
  HAGIWO MOD2 Break beats Ver1.0
  PCM break-beat playback module. Slice points are pre-programmed into the MCU and can be selected via CV.

  Operation overview
  1. External trigger or short button press starts playback from the selected start point.
  2. A0 sets playback speed (0.7–1.5×) with real‑time CV control.
  3. A1 sets playback length (0.3–2.3 s) with real‑time CV control.
  4. A2 selects one of six predefined start points within the sample.
  5. Loop mode automatically retriggers when playback reaches the end.
  6. Medium button press (>1 s) toggles loop mode; LED indicates when loop is active.
  7. Long button press (≥3 s) swaps between the two stored drum samples.
  8. GPIO0 outputs a 5 ms HIGH pulse just before playback finishes.
  9. 10‑bit PWM audio is generated on GPIO1 at ~36.6 kHz and should be RC‑filtered externally.
 10. All critical audio processing runs inside a high‑rate PWM interrupt for minimal latency.

--Pin assign---
POT1     A0       Playback speed CV / pot   (0.7 – 1.5 ×)
POT2     A1       Playback length CV / pot  (0.3 – 2.3 s)
POT3     A2       Sample index select within group
IN1      GPIO7    External trigger  (rising edge)
IN2      GPIO0    End‑of‑playback HIGH pulse (5 ms) ***use as output pin***
CV       A2       Shared with POT3
BUTTON   GPIO6    Manual button     (short / medium / long press)
OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
LED      GPIO5    Loop‑mode LED     (HIGH = loop)
EEPROM   N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include "hardware/gpio.h"
#include "sample.h"  // two sample sets + tables (placeholders here)

// ---------- Fixed‑point & PWM constants ----------
#define FRAC_BITS 12
#define FRAC_MASK ((1UL << FRAC_BITS) - 1)

#define SAMPLE_RATE 44100                                    // 44.1 kHz
const uint16_t PWM_FS = 1023;                                // 10‑bit full scale
const uint16_t PWM_MID = PWM_FS / 2;                         // DC offset
const uint16_t PWM_WRAP = 4095;                              // ~36.6 kHz interrupt rate
const uint32_t END_MARK_SAMPLES = (SAMPLE_RATE * 5) / 1000;  // 5 ms ≈ 220 samples

// Manual‑button timing thresholds
const uint32_t MODE_SWITCH_MS = 1000;    // medium press > 1 s
const uint32_t SAMPLE_SWITCH_MS = 3000;  // long press  ≥ 3 s

// ---------- Playback state ----------
volatile bool playing = false;       // true while audio is playing
volatile bool loopMode = false;      // false = 1‑shot, true = loop
volatile bool loopRetrig = false;    // request flag for loop restart
volatile uint8_t currentSample = 0;  // 0 or 1

volatile uint32_t tblAcc = 0;                    // fixed‑point play pointer (Q12)
volatile uint32_t tblStepFP = 1UL << FRAC_BITS;  // step size in Q12
volatile const uint8_t* curSample = sampleDatas[0];
volatile uint32_t curLen16 = sampleLens16[0];

uint sliceAudio, sliceIRQ;  // PWM slice numbers

// ---------- Manual‑button state ----------
bool btnPrev = true;    // previous state (true = released)
uint32_t btnStart = 0;  // press‑start timestamp

// Read 16‑bit PCM sample (little‑endian) from byte array
inline int16_t readPCM(const volatile uint8_t* base, uint32_t idx) {
  uint32_t byteIndex = idx << 1;  // idx * 2
  return int16_t(base[byteIndex] | (base[byteIndex + 1] << 8));
}

// PWM wrap interrupt – audio output & pointer update
void on_pwm_wrap() {
  pwm_clear_irq(sliceIRQ);

  if (!playing) {
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);  // silence
    gpio_put(0, 0);                                       // GPIO0 LOW
    return;
  }

  uint32_t idx = tblAcc >> FRAC_BITS;  // integer part
  uint32_t frac = tblAcc & FRAC_MASK;  // fractional part (0–4095)

  // ---- End‑of‑sample check ----
  if (idx >= curLen16) {
    gpio_put(0, 0);  // ensure LOW at the end
    if (loopMode) {
      playing = false;  // let main loop retrigger
      loopRetrig = true;
      tblAcc = 0;
      pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
      return;
    } else {
      playing = false;
      tblAcc = 0;
      pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
      return;
    }
  }

  // ---- GPIO0 HIGH during final 5 ms ----
  gpio_put(0, (curLen16 - idx <= END_MARK_SAMPLES));

  // ---- Linear interpolation ----
  int16_t s1 = readPCM(curSample, idx);
  int16_t s2 = (idx + 1 < curLen16) ? readPCM(curSample, idx + 1) : 0;
  int32_t mix = ((int32_t)s1 * ((1UL << FRAC_BITS) - frac) + (int32_t)s2 * frac) >> FRAC_BITS;
  uint16_t pwmVal = uint16_t(int32_t(mix) + 32768) >> 6;  // 16‑bit → 10‑bit
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, pwmVal);

  tblAcc += tblStepFP;
}

// Quantise A2 CV to one of six start‑point indices
uint8_t selectStartIndex() {
  uint16_t val = 1023 - analogRead(A2);  // invert so 0 V = high value
  if (val < 32) return 0;
  if (val < 248) return 1;
  if (val < 514) return 2;
  if (val < 720) return 3;
  if (val < 926) return 4;
  return 5;
}

// (Re)start playback using current CV values & selected sample
void startPlayback() {
  playing = false;
  tblAcc = 0;
  gpio_put(0, 0);
  delay(5);
  // --- Determine start point ---
  uint8_t startIdx = selectStartIndex();
  const long* stbl = startTables[currentSample];
  uint32_t startSample = stbl[startIdx];

  // --- Playback length (0.3–2.3 s) ---
  uint16_t rawLen = analogRead(A1);
  float durationSec = 0.3f + (rawLen / 1023.0f) * 2.0f;  // 2.0 s span
  uint32_t playSamples = uint32_t(durationSec * SAMPLE_RATE);

  uint32_t totalLen = sampleLens16[currentSample];
  if (startSample + playSamples > totalLen)
    playSamples = totalLen - startSample;

  // --- Set sample pointer ---
  curSample = sampleDatas[currentSample] + (startSample << 1);  // ×2 for bytes
  curLen16 = playSamples;

  // --- Playback speed (0.7–1.5×) ---
  uint16_t rawSpeed = analogRead(A0);
  float rate = 0.7f + (rawSpeed / 1023.0f) * 0.8f;
  tblStepFP = uint32_t(rate * float(1 << FRAC_BITS));

  playing = true;
}

// External trigger ISR (GPIO7)
void onExtTrigger() {
  startPlayback();
}

void setup() {
  analogReadResolution(10);  // 10‑bit ADC

  // GPIO0 output (end‑of‑playback pulse)
  gpio_init(0);
  gpio_set_dir(0, GPIO_OUT);
  gpio_put(0, 0);

  // Loop‑mode LED
  pinMode(5, OUTPUT);
  digitalWrite(5, LOW);
  // Manual button (GPIO6, active‑low)
  pinMode(6, INPUT_PULLUP);

  // PWM audio output (GPIO1) + dummy channel (GPIO2) for IRQ timing
  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceIRQ = pwm_gpio_to_slice_num(2);
  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, PWM_FS);
  pwm_set_enabled(sliceAudio, true);
  pwm_set_clkdiv(sliceIRQ, 1);
  pwm_set_wrap(sliceIRQ, PWM_WRAP);
  pwm_set_enabled(sliceIRQ, true);
  pwm_clear_irq(sliceIRQ);
  pwm_set_irq_enabled(sliceIRQ, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  // External trigger (GPIO7)
  pinMode(7, INPUT);
  attachInterrupt(digitalPinToInterrupt(7), onExtTrigger, RISING);
}

void loop() {
  // ---- Manual button handling ----
  bool btnNow = (digitalRead(6) == LOW);  // active‑low
  uint32_t nowMs = millis();

  if (!btnPrev && btnNow) {  // pressed
    btnStart = nowMs;

  } else if (btnPrev && !btnNow) {  // released
    uint32_t dt = nowMs - btnStart;

    if (dt < MODE_SWITCH_MS) {
      // ① Short press: trigger
      startPlayback();

    } else if (dt < SAMPLE_SWITCH_MS) {
      // ② Medium press: toggle loop / 1‑shot
      loopMode = !loopMode;
      digitalWrite(5, loopMode ? HIGH : LOW);

    } else {
      // ③ Long press: switch sample
      currentSample ^= 1;  // 0 ↔ 1
      if (playing)         // update immediately if currently playing
        startPlayback();
    }
  }
  btnPrev = btnNow;

  // ---- Loop retrigger ----
  if (loopMode && loopRetrig) {
    loopRetrig = false;
    startPlayback();
  }
}
