/*
HAGIWO MOD2 Sample Player Ver1.0

  • It is possible to save audio files up to a total of 20 seconds / 18 files.
  • One-shot digital sample playback: plays 16-bit PCM samples stored in flash
  • 18 samples selectable via two-stage selection: group (A1) and sub-index (A2)
  • Playback speed control (A0): 0.5× to 1.5× speed with linear interpolation anti-aliasing
  • Trigger inputs (GPIO7 rising-edge, GPIO6 falling-edge) start playback
  • Trigger LED indicator (GPIO5): lights for 20 ms on trigger
  • PWM audio output (GPIO1) at ~36.6 kHz using 10-bit resolution

  --Pin assign---
POT1     A0       Playback speed control (0.5×–1.5×)
POT2     A1       Sample group select (1–6, 7–12, 13–18)
POT3     A2       Sample index select within group
IN1      GPIO7    External trigger (rising-edge)
IN2      GPIO0    select +6 sample number
CV       A2       Shared with POT3
BUTTON   GPIO6    Manual trigger (active-low, pull-up)
OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
LED      GPIO5    Trigger LED indicator (20 ms pulse)
EEPROM   N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include "sample.h"   // Header file containing sample data arrays

#define FRAC_BITS    12
#define FRAC_MASK    ((1UL << FRAC_BITS) - 1)

const uint16_t PWM_FS   = 1023;
const uint16_t PWM_MID  = PWM_FS / 2;
const uint16_t PWM_WRAP = 4095;

volatile bool     playing     = false;
volatile uint32_t tblAcc      = 0;
volatile uint32_t tblStepFP   = 1UL << FRAC_BITS;
volatile const uint8_t* curSample = sample01;
volatile uint32_t curLen16   = sampleLens[0];

uint sliceAudio, sliceIRQ;

volatile bool ledOn     = false;
uint32_t     ledOnTime = 0;

inline int16_t readPCM(const volatile uint8_t* base, uint32_t idx) {
  uint32_t byteIndex = idx << 1;
  return int16_t(base[byteIndex] | (base[byteIndex + 1] << 8));
}

void on_pwm_wrap() {
  pwm_clear_irq(sliceIRQ);

  if (!playing) {
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
    return;
  }

  uint32_t idx  = tblAcc >> FRAC_BITS;
  uint32_t frac = tblAcc & FRAC_MASK;

  if (idx >= curLen16) {
    playing = false;
    tblAcc  = 0;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
    return;
  }

  int16_t s1 = readPCM(curSample, idx);
  int16_t s2 = (idx + 1 < curLen16) ? readPCM(curSample, idx + 1) : 0;
  int32_t mix = ((int32_t)s1 * ( (1UL<<FRAC_BITS) - frac ) + (int32_t)s2 * frac) >> FRAC_BITS;
  int16_t interpolated = int16_t(mix);

  uint16_t pwmVal = uint16_t(int32_t(interpolated) + 32768) >> 6;
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, pwmVal);

  tblAcc += tblStepFP;
}

uint8_t selectSampleIndex() {
  uint16_t groupVal = analogRead(A1);

  uint8_t group;
  if (groupVal <= 341)        group = 0;
  else if (groupVal <= 684)   group = 1;
  else                        group = 2;

  uint16_t val = 1023 - analogRead(A2);
  uint8_t subIndex;
  if (val < 32)        subIndex = 0;
  else if (val < 248)  subIndex = 1;
  else if (val < 514)  subIndex = 2;
  else if (val < 720)  subIndex = 3;
  else if (val < 926)  subIndex = 4;
  else                  subIndex = 5;

  uint8_t index = group * 6 + subIndex;

  if (digitalRead(0) == HIGH) {
    index += 6;
    if (index >= 18) {
      index = index % 6;
    }
  }

  return index;
}

void onTriggerRising() {
  playing = false;
  tblAcc  = 0;
  delay(5);

  uint8_t idx = selectSampleIndex();
  curSample = samples[idx];
  curLen16  = sampleLens[idx];

  uint16_t raw = analogRead(A0);
  float rate   = 0.5f + (raw / 1023.0f);
  tblStepFP    = uint32_t(rate * float(1 << FRAC_BITS));

  digitalWrite(5, HIGH);
  ledOn     = true;
  ledOnTime = millis();

  playing = true;
}

void setup() {
  analogReadResolution(10);

  pinMode(0, INPUT);
  pinMode(5, OUTPUT);
  digitalWrite(5, LOW);

  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceIRQ   = pwm_gpio_to_slice_num(2);

  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap  (sliceAudio, PWM_FS);
  pwm_set_enabled(sliceAudio, true);

  pwm_set_clkdiv(sliceIRQ, 1);
  pwm_set_wrap  (sliceIRQ, PWM_WRAP);
  pwm_set_enabled(sliceIRQ, true);
  pwm_clear_irq     (sliceIRQ);
  pwm_set_irq_enabled(sliceIRQ, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  pinMode(7, INPUT);
  attachInterrupt(digitalPinToInterrupt(7), onTriggerRising, RISING);
  pinMode(6, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(6), onTriggerRising, FALLING);
}

void loop() {
  if (ledOn && (millis() - ledOnTime >= 20)) {
    digitalWrite(5, LOW);
    ledOn = false;
  }
}
