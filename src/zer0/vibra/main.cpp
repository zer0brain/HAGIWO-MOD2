/*
HAGIWO MOD2

zer0 Vibra v1.0
Three-voice chord vibra with sweet-spot to chaos control.

-- Pin assignment --
POT1   A0     Base tone
POT2   A1     Chaos/Mode
POT3   A2     Decay
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
CV     A2     Shared with POT3
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Trigger indicator
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/


#include <Arduino.h>
#include <math.h>

#define PWM_PIN        1
#define TRIG_PIN       7
#define LED_PIN        5
#define BTN_MODE       6
#define POT_0_TONE     A0
#define POT_1_MODE     A1
#define POT_2_DECAY    A2

#define SR             22050.0f
#define PWM_RES        1024
#define PWM_MID        (PWM_RES / 2)
#define TWO_PI         6.28318530718f

struct Note {
  float phase = 0, freq = 0, env = 0, env_step = 0;
  float mod_phase = 0;
  bool active = false;
};

Note notes[3];
int mode = 0;
bool last_btn = false;
unsigned long lastTrigger = 0;

void playNote(int idx, float freq, float decay) {
  notes[idx].freq = freq;
  notes[idx].phase = 0;
  notes[idx].mod_phase = 0;
  notes[idx].env = 1.0f;
  notes[idx].env_step = 1.0f / (decay * SR);
  notes[idx].active = true;
}

void setup() {
  pinMode(PWM_PIN, OUTPUT);
  pinMode(TRIG_PIN, INPUT);
  pinMode(BTN_MODE, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(SR);
  analogWriteRange(PWM_RES);
}

void loop() {
  float base = 220.0f + analogRead(POT_0_TONE)/1023.0f * 300.0f;
  float decay = 1.1f - analogRead(POT_2_DECAY)/1023.0f * 1.0f;
  float chaos = analogRead(POT_1_MODE)/1023.0f;  // 0=sweet, 1=extreme
  
  // Detune scaling: sweet spot around 0.3, extreme at edges
  float detune_base = (chaos - 0.5f) * 2.0f;  // -1 to 1
  float detune_factor = (chaos < 0.3f) ? 
                        chaos * 0.04f / 0.3f :  // 0-0.04 (sweet spot)
                        0.04f + (chaos - 0.3f) * 0.46f / 0.7f;  // 0.04-0.5 (extreme)
  float detune = detune_base * detune_factor;

  // Mode button
  bool btn = !digitalRead(BTN_MODE);
  if (btn && !last_btn) {
    mode = (mode + 1) % 4;
    delay(200);
  }
  last_btn = btn;

  // Trigger (simple rate limit)
  bool trig = digitalRead(TRIG_PIN);
  if(trig && millis() - lastTrigger > 1000) {
    // Interval chaos: sweet at low chaos, extreme at high
    float interval1 = (chaos < 0.3f) ? 4.0f/12.0f : 4.0f/12.0f + (chaos - 0.3f) * 8.0f/12.0f;
    float interval2 = (chaos < 0.3f) ? -1.0f/12.0f : -1.0f/12.0f - (chaos - 0.3f) * 6.0f/12.0f;
    
    playNote(0, base * pow(2.0f, interval1), decay);
    playNote(1, base * pow(2.0f, interval2) * (1.0f + detune), decay);
    playNote(2, base * pow(2.0f, interval2) * (1.0f - detune), decay);
    lastTrigger = millis();
  }

  float mix = 0;
  for(int i=0; i<3; i++) {
    if(notes[i].active) {
      notes[i].phase += TWO_PI * notes[i].freq / SR;
      notes[i].mod_phase += TWO_PI * 6.0f / SR;
      if(notes[i].phase > TWO_PI) notes[i].phase -= TWO_PI;
      if(notes[i].mod_phase > TWO_PI) notes[i].mod_phase -= TWO_PI;

      float tone = 0;
      float fm_intensity = chaos * chaos * 5.0f;  // 0-5, squared curve for sweet spot
      switch(mode) {
        case 0: // Clean to harsh
          if (chaos < 0.3f) {
            tone = sin(notes[i].phase);
          } else {
            float harsh = (chaos - 0.3f) / 0.7f;
            tone = sin(notes[i].phase) * (1.0f - harsh) + 
                   tanh(sin(notes[i].phase) * (1.0f + harsh * 4.0f)) * harsh;
          }
          break;
        case 1: // FM intensity scaling
          tone = sin(notes[i].phase + fm_intensity * 0.2f * sin(notes[i].mod_phase));
          break;
        case 2: // Self-FM with chaos
          tone = sin(notes[i].phase + fm_intensity * 0.3f * sin(2.0f * notes[i].phase));
          break;
        case 3: // Harmonic chaos
          float h2 = (chaos < 0.4f) ? 0.3f : 0.3f + (chaos - 0.4f) * 1.7f;
          float h3 = (chaos < 0.4f) ? 0.1f : 0.1f + (chaos - 0.4f) * 0.9f;
          tone = 0.6f * sin(notes[i].phase) + h2 * sin(2.0f * notes[i].phase) + h3 * sin(3.0f * notes[i].phase);
          if (chaos > 0.7f) tone = tanh(tone * (1.0f + chaos * 2.0f));
          break;
      }

      float env_soft = notes[i].env * notes[i].env;
      float attack = 1.0f - exp(-notes[i].env * 6.0f);
      
      // Chaos affects envelope character
      float env_final = (chaos < 0.5f) ? 
                        env_soft * attack :  // Sweet: soft envelope
                        notes[i].env * attack * (1.0f + chaos);  // Extreme: harder envelope
      
      mix += tone * env_final * 0.5f;

      notes[i].env -= notes[i].env_step;
      if(notes[i].env < 0) notes[i].active = false;
    }
  }

  digitalWrite(LED_PIN, mix > 0.01f ? HIGH : LOW);

  int pwm = PWM_MID + (int)(mix * PWM_MID);
  pwm = constrain(pwm, 0, PWM_RES - 1);
  analogWrite(PWM_PIN, pwm);
  delayMicroseconds(45);
}
