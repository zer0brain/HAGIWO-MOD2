/*
HAGIWO MOD2

zer0 Bassline v1.0
Detuned unison bass synth with simple resonant filter and accent.

-- Pin assignment --
POT1   A0   Note/Frequency (for testing)
POT2   A1   Filter cutoff
POT3   A2   Resonance/Aggro
IN1    GPIO7  Gate (hold = sustain, release = decay)
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Wave/Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/


#include <Arduino.h>
#include <math.h>

#define PWM_OUTPUT_PIN 1
#define GATE_PIN 7      // Note trigger (hold = sustain, release = decay)
#define ACCENT_PIN 0
#define BUTTON_PIN 6
#define LED_PIN 5
#define POT1_PIN A0     // Note/Frequency (for testing)
#define POT2_PIN A1     // Filter cutoff
#define POT3_PIN A2     // Resonance/Aggro

#define SAMPLE_RATE 22050.0f
#define PWM_RES 1024
#define PWM_MID (PWM_RES / 2)
#define NUM_MODES 3

struct UnisonOsc {
  float phase;
  float detune;
};

struct BassSynth {
  float freq = 55.0f;
  float cutoff = 400.0f;
  float resonance = 0.4f;
  float env = 0.0f;
  float env_decay = 0.996f;
  float aggro = 1.0f;
  bool gate = false;
  bool accent = false;
  int mode = 0;
  float lfo_phase = 0.0f;
  float lfo = 0.0f;
  UnisonOsc osc[5];
  float sub_phase = 0.0f;
  float buf1 = 0, buf2 = 0, buf3 = 0, filt_out = 0;
} synth;

bool last_gate = false;
bool last_btn = false;
unsigned long last_btn_time = 0;

void setup() {
  pinMode(PWM_OUTPUT_PIN, OUTPUT);
  pinMode(GATE_PIN, INPUT);
  pinMode(ACCENT_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(SAMPLE_RATE);
  analogWriteRange(PWM_RES);

  synth.osc[0].detune = 0.0f;
  synth.osc[1].detune = -0.012f;
  synth.osc[2].detune = 0.019f;
  synth.osc[3].detune = -0.028f;
  synth.osc[4].detune = 0.034f;
  for (int i = 0; i < 5; i++) synth.osc[i].phase = 0.0f;
  synth.sub_phase = 0.0f;
}

void loop() {
  // POT1 sets pitch (for real acid/DnB use CV/MIDI/sequencer instead)
  float note_val = analogRead(POT1_PIN) / 1023.0f;
  synth.freq = 32.0f + note_val * 220.0f; // 32–252 Hz (C1…B3 bass range)

  float filter_pot = analogRead(POT2_PIN) / 1023.0f;
  float res_pot = analogRead(POT3_PIN) / 1023.0f;
  synth.cutoff = 120.0f + powf(filter_pot, 1.6f) * 3500.0f; // Sweetspot in Mitte
  synth.resonance = 0.10f + powf(res_pot, 1.3f) * 0.92f;    // 0.1 ... 1.0

  // Accent
  bool accent = digitalRead(ACCENT_PIN);

  // Button = Mode (Saw/Rect/Unison+Noise)
  bool btn = !digitalRead(BUTTON_PIN);
  if (btn && !last_btn && millis() - last_btn_time > 110) {
    synth.mode = (synth.mode + 1) % NUM_MODES;
    last_btn_time = millis();
  }
  last_btn = btn;

  // Gate: sustain bass (hold = sustain, release = decay)
  bool gate = digitalRead(GATE_PIN);
  if (gate && !last_gate) {
    synth.gate = true;
    synth.env = 1.0f;
    synth.accent = accent;
    synth.lfo_phase = 0.0f;
    for (int i = 0; i < 5; i++) synth.osc[i].phase = 0.0f;
    synth.sub_phase = 0.0f;
  } else if (!gate && last_gate) {
    synth.gate = false;
  }
  last_gate = gate;

  // Envelope
  if (!synth.gate) synth.env *= synth.env_decay;
  if (synth.env < 0.0007f) synth.env = 0.0f;

  // Unison oscillator stack (saw/square/optional noise)
  float sum = 0.0f;
  for (int i = 0; i < 5; i++) {
    synth.osc[i].phase += ((synth.freq * (1.0f + synth.osc[i].detune * (synth.mode == 2 ? 1.0f : 0.23f))) * 2.0f * PI) / SAMPLE_RATE;
    if (synth.osc[i].phase >= 2.0f * PI) synth.osc[i].phase -= 2.0f * PI;

    float wave = 0.0f;
    switch (synth.mode) {
      case 0: wave = (synth.osc[i].phase / PI) - 1.0f; break;           // Saw
      case 1: wave = (synth.osc[i].phase < PI) ? 1.0f : -1.0f; break;   // Square
      case 2: // Acid: Detuned Saw + Noise
        wave = ((synth.osc[i].phase / PI) - 1.0f) + ((random(-700, 700) / 700.0f) * 0.22f);
        break;
    }
    sum += wave;
  }
  sum /= 5.0f;

  // Sub oscillator (one octave lower, saw for acid)
  synth.sub_phase += (synth.freq * 0.5f * 2.0f * PI) / SAMPLE_RATE;
  if (synth.sub_phase >= 2.0f * PI) synth.sub_phase -= 2.0f * PI;
  float sub = (synth.sub_phase / PI) - 1.0f; // Sub als Saw

  // Mix
  float mix = sum * 0.72f + sub * 0.27f;
  if (synth.accent) mix *= 1.18f;

  // Aggro/Distortion
  float distorted = tanh(mix * (1.3f + 1.2f * synth.resonance));

  // Envelope Anwendung
  float out_env = distorted * synth.env;

  // Filter: Resonanz-LP (TB-Style, max stable)
  float cf = synth.cutoff / SAMPLE_RATE;
  if (cf > 0.47f) cf = 0.47f;
  float f = 2.0f * sinf(PI * cf);
  float q = synth.resonance;
  synth.buf1 += f * (out_env - synth.buf1 - q * synth.filt_out);
  synth.buf2 += f * (synth.buf1 - synth.buf2);
  synth.buf3 += f * (synth.buf2 - synth.buf3);
  if (synth.buf1 > 12.0f) synth.buf1 = 12.0f; if (synth.buf1 < -12.0f) synth.buf1 = -12.0f;
  if (synth.buf2 > 12.0f) synth.buf2 = 12.0f; if (synth.buf2 < -12.0f) synth.buf2 = -12.0f;
  if (synth.buf3 > 12.0f) synth.buf3 = 12.0f; if (synth.buf3 < -12.0f) synth.buf3 = -12.0f;

  synth.filt_out = synth.buf3 + q * 0.11f * synth.buf3;

  // DC offset removal
  static float dc = 0;
  dc += 0.001f * (synth.filt_out - dc);
  float out = synth.filt_out - dc;

  // Final Output
  float final = tanh(out * (synth.accent ? 1.36f : 1.09f));
  int pwm = PWM_MID + (int)(final * PWM_MID * 0.91f);
  if (pwm < 0) pwm = 0;
  if (pwm >= PWM_RES) pwm = PWM_RES - 1;
  analogWrite(PWM_OUTPUT_PIN, pwm);

  digitalWrite(LED_PIN, synth.env > 0.008f ? HIGH : LOW);
  delayMicroseconds(44); // ~22kHz
}
