/*
HAGIWO MOD2

zer0 Micro Sampler v3.2
Simple 2-sample micro-sampler with trigger, sample select button, LED playback indicator,
start point, pitch, and a lowpass filter (POT3).

- Button cycles through available samples. LED blinks on playback.
- Trigger input starts playback from the selected sample and start point.
- POT1 (A0): Start/End point (0–90% of sample)
- POT2 (A1): Pitch (0.5x to 2x original rate)
- POT3 (A2): Lowpass filter (bright to dull)
- IN2 (D0): Accent input (HIGH = reverse playback)
- LED (D2): Playback indicator
- IN1 (D7): Trigger input (rising edge)
- BUTTON (D6): Sample select
- OUT (D1): Audio output (PWM)

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v3.2  - Lowpass filter via POT3
v3.1  - Reverse playback via Accent, removed volume control
v3.0  - Start point control, improved comments, code cleanup
v2.0  - Pitch and volume control, LED indicator
v1.0  - Initial release
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>
#include <stdint.h>

// --- Include your sample data headers here ---
#include "sample1_data.h"
#include "sample2_data.h"

// --- Pin assignment ---
#define PWM_OUTPUT_PIN 1
#define TRIGGER_INPUT_PIN 7
#define ACCENT_INPUT_PIN 0
#define BUTTON_PIN 6 
#define POT_STARTPOINT_PIN A0 // POT1: Start/End point
#define POT_PITCH_PIN A1      // POT2: Pitch
#define POT_FILTER_PIN A2     // POT3: Lowpass filter
#define LED_PIN 2             // Playback indicator

// --- PWM configuration ---
#define PWM_FS 1023.0f
#define PWM_MID (PWM_FS / 2.0f)
const float SYSTEM_CLOCK_HZ = 150000000.0f;
const float PLAYBACK_SAMPLE_RATE = SYSTEM_CLOCK_HZ / (4.0f * (PWM_FS + 1.0f));

// --- Sample Structure & Data ---
struct Sample {
    const int16_t* data;
    uint32_t len;
    uint32_t original_rate;
    const char* name;
};
const Sample available_samples[] = {
    {sample1_data, sample1_data_len, sample1_original_rate, "Sample 1"},
    {sample2_data, sample2_data_len, sample2_original_rate, "Sample 2"}
};
const int NUM_SAMPLES = sizeof(available_samples) / sizeof(available_samples[0]);

// --- Playback State ---
volatile bool playing = false;
volatile float playback_fidx = 0.0f;
volatile float playback_step = 1.0f;
volatile int current_sample_idx = 0;
volatile float sample_point_factor = 0.0f; // 0.0 = start, 0.9 = 90% of sample
volatile bool reverse_playback = false;
volatile float filter_alpha = 1.0f; // Lowpass filter coefficient

// --- Debouncing Globals ---
volatile unsigned long last_trigger_time = 0;
const unsigned long debounce_delay = 20; // ms
int last_button_state = HIGH;
unsigned long last_button_press_time = 0;

// --- PWM Interrupt Service Routine ---
// Outputs next sample value to PWM. Handles interpolation and end-of-sample logic.
void on_pwm_wrap() {
    uint slice_num = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    pwm_clear_irq(slice_num);

    static float last_filtered = 0.0f; // For lowpass filter

    if (!playing) {
        pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
        last_filtered = 0.0f;
        return;
    }

    const Sample* current_s = &available_samples[current_sample_idx];
    uint32_t idx0 = (uint32_t)playback_fidx;

    // End of sample: stop playback, turn off LED
    if ((!reverse_playback && idx0 >= current_s->len - 1) ||
        (reverse_playback && idx0 == 0)) {
        playing = false;
        digitalWrite(LED_PIN, LOW);
        pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
        last_filtered = 0.0f;
        return;
    }

    // Linear interpolation between two samples for smooth playback
    float frac = playback_fidx - idx0;
    int16_t s0 = current_s->data[idx0];
    int16_t s1 = current_s->data[reverse_playback ? idx0 - 1 : idx0 + 1];
    float interpolated_sample_float = (float)s0 * (1.0f - frac) + (float)s1 * frac;
    float normalized_sample = interpolated_sample_float / 32768.0f;

    // --- Simple 1-pole lowpass filter ---
    float filtered = filter_alpha * normalized_sample + (1.0f - filter_alpha) * last_filtered;
    last_filtered = filtered;

    uint16_t pwm_val = (uint16_t)((filtered + 1.0f) * 0.5f * PWM_FS);
    pwm_val = max((uint16_t)0, min((uint16_t)PWM_FS, pwm_val));
    pwm_set_chan_level(slice_num, PWM_CHAN_B, pwm_val);

    playback_fidx += reverse_playback ? -playback_step : playback_step;
}

// --- Trigger handler ---
// Start playback from the selected sample and start point.
void onTrig() {
    unsigned long current_time = millis();
    if (current_time - last_trigger_time < debounce_delay) {
        return;
    }
    last_trigger_time = current_time;

    if (NUM_SAMPLES == 0) return;

    reverse_playback = digitalRead(ACCENT_INPUT_PIN);

    const Sample* s = &available_samples[current_sample_idx];
    if (reverse_playback) {
        playback_fidx = (float)(s->len - 1) * sample_point_factor;
        if (playback_fidx < 1.0f) playback_fidx = 1.0f; // avoid underrun
    } else {
        playback_fidx = (float)(s->len - 1) * sample_point_factor;
    }

    playing = true;
    digitalWrite(LED_PIN, HIGH);
}

// --- Setup ---
void setup() {
    analogReadResolution(10);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);

    // PWM setup for audio output
    uint slice_num = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    gpio_set_function(PWM_OUTPUT_PIN, GPIO_FUNC_PWM);
    pwm_set_clkdiv_int_frac(slice_num, 4, 0);
    pwm_set_wrap(slice_num, (uint16_t)PWM_FS);
    pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
    pwm_set_enabled(slice_num, true);
    pwm_clear_irq(slice_num);
    pwm_set_irq_enabled(slice_num, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    pinMode(TRIGGER_INPUT_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(TRIGGER_INPUT_PIN), onTrig, RISING);

    pinMode(ACCENT_INPUT_PIN, INPUT);
}

// --- Main Loop ---
void loop() {
    // 1) Button for sample selection (debounced)
    int current_button_state = digitalRead(BUTTON_PIN);
    if (current_button_state == LOW && last_button_state == HIGH) {
        if (millis() - last_button_press_time > 50) {
            current_sample_idx = (current_sample_idx + 1) % NUM_SAMPLES;
            last_button_press_time = millis();
        }
    }
    last_button_state = current_button_state;

    // 2) POT1: Sample start/end point (smoothed, 0.0–0.9)
    uint32_t point_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
         point_adc_sum += analogRead(POT_STARTPOINT_PIN);
    }
    sample_point_factor = (point_adc_sum / 4.0f / 1023.0f) * 0.9f;

    // 3) POT2: Pitch control (0.5x to 4x)
    uint32_t pitch_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
        pitch_adc_sum += analogRead(POT_PITCH_PIN);
    }
    float pitch_pot_val = (pitch_adc_sum / 4.0f) / 1023.0f;
    float pitch_factor = 0.5f + pitch_pot_val * 3.5f; //  0.5x bis 4.0x
    const Sample* selected_s = &available_samples[current_sample_idx];
    playback_step = ((float)selected_s->original_rate / PLAYBACK_SAMPLE_RATE) * pitch_factor;
    if (playback_step <= 0.0f) playback_step = 0.001f;

    // 4) POT3: Lowpass filter (bright to dull)
    uint32_t filter_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
        filter_adc_sum += analogRead(POT_FILTER_PIN);
    }
    float filter_pot_val = (filter_adc_sum / 4.0f) / 1023.0f;
    // Map to alpha: 0.2 (dull) ... 1.0 (bright)
    filter_alpha = 0.2f + filter_pot_val * 0.8f;

    delay(10);
}