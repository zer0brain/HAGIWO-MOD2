/*
HAGIWO MOD2

zer0 Hi-Hat v1.0
TR-909 style hi-hat emulator for PWM audio with accent and 3 parameters.

-- Pin assignment --
POT1   A0   Tone (filter)
POT2   A1   Metallic amount
POT3   A2   Decay
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/


#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>

#define PWM_OUTPUT_PIN 1
#define TRIGGER_INPUT_PIN 7
#define ACCENT_INPUT_PIN 0
#define BUTTON_PIN 6
#define LED_PIN 5
#define POT_TONE_PIN A0
#define POT_METAL_PIN A1
#define POT_DECAY_PIN A2

#define PWM_FS 1023.0f
#define PWM_MID (PWM_FS / 2.0f)
const float SYSTEM_CLOCK_HZ = 150000000.0f;
const float AUDIO_RATE = SYSTEM_CLOCK_HZ / (4.0f * (PWM_FS + 1.0f));

// --- HiHat Synthesis State ---
volatile bool playing = false;
volatile float env = 0.0f;
volatile float decay = 0.995f;
volatile float tone_amt = 0.5f;
volatile float metallic = 0.5f;
volatile bool accent = false;

// --- Noise/Metallic Oscillators ---
volatile uint32_t noise_lfsr = 0xACE1;
volatile float osc1 = 0, osc2 = 0, osc3 = 0, osc4 = 0, osc5 = 0, osc6 = 0;
volatile float phase1 = 0, phase2 = 0, phase3 = 0, phase4 = 0, phase5 = 0, phase6 = 0;

// --- Debounce ---
volatile unsigned long last_trig = 0;
const unsigned long debounce_ms = 20;

// --- HiHat Typen ---
const char* hihat_names[] = {"Closed", "Open", "Pedal", "Accent"};
volatile int hihat_type = 0;
volatile bool led_blink = false;
volatile unsigned long led_blink_until = 0;

// --- PWM ISR ---
void on_pwm_wrap() {
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    pwm_clear_irq(slice);
    if (!playing) {
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
        digitalWrite(LED_PIN, LOW); // LED off when the sound ends
        return;
    }
    // 909-style: six square oscillators plus noise
    // Frequencies inspired by the 909 service manual, slightly detuned
    phase1 += 410.0f + 2000.0f * metallic;
    phase2 += 620.0f + 1800.0f * metallic;
    phase3 += 830.0f + 1600.0f * metallic;
    phase4 += 950.0f + 1400.0f * metallic;
    phase5 += 1050.0f + 1200.0f * metallic;
    phase6 += 1180.0f + 1000.0f * metallic;
    if (phase1 > AUDIO_RATE) phase1 -= AUDIO_RATE;
    if (phase2 > AUDIO_RATE) phase2 -= AUDIO_RATE;
    if (phase3 > AUDIO_RATE) phase3 -= AUDIO_RATE;
    if (phase4 > AUDIO_RATE) phase4 -= AUDIO_RATE;
    if (phase5 > AUDIO_RATE) phase5 -= AUDIO_RATE;
    if (phase6 > AUDIO_RATE) phase6 -= AUDIO_RATE;
    osc1 = (phase1 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    osc2 = (phase2 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    osc3 = (phase3 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    osc4 = (phase4 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    osc5 = (phase5 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    osc6 = (phase6 < AUDIO_RATE/2) ? 1.0f : -1.0f;
    // Noise
    uint32_t bit = ((noise_lfsr >> 0) ^ (noise_lfsr >> 2) ^ (noise_lfsr >> 3) ^ (noise_lfsr >> 5)) & 1;
    noise_lfsr = (noise_lfsr >> 1) | (bit << 15);
    float noise = ((float)((int16_t)noise_lfsr) / 32768.0f);
    // Mix
    float sig = (osc1 + osc2 + osc3 + osc4 + osc5 + osc6) * 0.09f + noise * (0.64f + 0.3f * metallic);
    // Envelope
    sig *= env;
    // Tone filter (1‑pole low‑pass with extended range)
    static float lp = 0.0f;
    float cutoff = 2000.0f + 16000.0f * tone_amt; // 2–18 kHz (wide range)
    float alpha = cutoff / AUDIO_RATE;
    if (alpha > 1.0f) alpha = 1.0f;
    lp = alpha * sig + (1.0f - alpha) * lp;
    float out = lp;
    // Accent
    if (accent) out *= 1.5f;
    // Envelope decay
    env *= decay;
    if (env < 0.001f) {
        playing = false;
        env = 0.0f;
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    digitalWrite(LED_PIN, LOW); // LED off when the sound ends
        return;
    }
    // Output
    float limited = tanhf(out * 1.2f);
    uint16_t pwm_val = (uint16_t)((limited + 1.0f) * 0.5f * PWM_FS);
    pwm_val = max((uint16_t)0, min((uint16_t)PWM_FS, pwm_val));
    pwm_set_chan_level(slice, PWM_CHAN_B, pwm_val);
}

void onTrig() {
    unsigned long now = millis();
    if (now - last_trig < debounce_ms) return;
    last_trig = now;
    accent = digitalRead(ACCENT_INPUT_PIN);
    env = 1.0f;
    playing = true;
    digitalWrite(LED_PIN, HIGH); // LED on when triggered
}

void setup() {
    analogReadResolution(10);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    gpio_set_function(PWM_OUTPUT_PIN, GPIO_FUNC_PWM);
    pwm_set_clkdiv_int_frac(slice, 4, 0);
    pwm_set_wrap(slice, (uint16_t)PWM_FS);
    pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    pwm_set_enabled(slice, true);
    pwm_clear_irq(slice);
    pwm_set_irq_enabled(slice, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);
    pinMode(TRIGGER_INPUT_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(TRIGGER_INPUT_PIN), onTrig, RISING);
    pinMode(ACCENT_INPUT_PIN, INPUT);
}

void loop() {
    // Button cycles the Hi‑Hat type
    static int last_button = HIGH;
    int button = digitalRead(BUTTON_PIN);
    if (button == LOW && last_button == HIGH) {
        hihat_type = (hihat_type + 1) % 4;
        delay(100); // Debounce
    }
    last_button = button;

    // Read parameters
    float decay_pot = analogRead(POT_DECAY_PIN) / 1023.0f;
    float tone_pot = analogRead(POT_TONE_PIN) / 1023.0f;
    float metal_pot = analogRead(POT_METAL_PIN) / 1023.0f;
    
    // Invert decay: left = short, right = long
    decay_pot = 1.0f - decay_pot;
    
    // Type‑specific mappings (wide, expressive ranges)
    switch (hihat_type) {
        case 0: // Closed
            decay = 0.985f + decay_pot * 0.012f; // 0.985–0.997
            tone_amt = 0.2f + tone_pot * 0.8f;   // 0.2–1.0
            metallic = 0.1f + metal_pot * 0.8f;  // 0.1–0.9
            break;
        case 1: // Open
            decay = 0.990f + decay_pot * 0.009f; // 0.990–0.999 (long)
            tone_amt = 0.0f + tone_pot * 1.0f;   // 0.0–1.0
            metallic = 0.2f + metal_pot * 0.8f;  // 0.2–1.0
            break;
        case 2: // Pedal
            decay = 0.987f + decay_pot * 0.011f; // 0.987–0.998
            tone_amt = 0.0f + tone_pot * 0.9f;   // 0.0–0.9
            metallic = 0.0f + metal_pot * 0.9f;  // 0.0–0.9
            break;
        case 3: // Accent
            decay = 0.980f + decay_pot * 0.018f; // 0.980–0.998
            tone_amt = 0.3f + tone_pot * 0.7f;   // 0.3–1.0
            metallic = 0.4f + metal_pot * 0.6f;  // 0.4–1.0
            break;
    }
    delay(5);
}
