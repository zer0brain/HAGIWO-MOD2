/*
HAGIWO MOD2

zer0 Wind Noise v1.0
Wind/air textures using noise and formant filters with multiple modes.

-- Pin assignment --
POT1   A0   Decay time
POT2   A1   Character
POT3   A2   Modulation
IN1    GPIO7  Trigger
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>

// Pin assignment
#define PWM_OUTPUT_PIN 1
#define TRIGGER_INPUT_PIN 7
#define BUTTON_PIN 6
#define LED_PIN 5
#define POT1_PIN A0  // Decay Time
#define POT2_PIN A1  // Character
#define POT3_PIN A2  // Modulation

#define SAMPLE_RATE 22050.0f
#define PWM_RES 1024
#define PWM_MID (PWM_RES / 2)
#define TWO_PI 6.28318530718f

struct VoiceDemon {
  float env = 0.0f;
  float env_step = 0.0f;
  float form_phase[3] = {};
  bool last_trig = false;
  bool last_btn = false;
  unsigned long last_btn_time = 0;
  int mode = 0;
} synth;

uint32_t seed = 0xBADC0DE;
float fast_noise() {
  seed = seed * 1664525 + 1013904223;
  return ((seed >> 16) & 0xFFFF) / 32768.0f - 1.0f;
}

float formant_bandpass(float input, float freq, float q, int i) {
  static float z1[3] = {}, z2[3] = {};
  float w0 = TWO_PI * freq / SAMPLE_RATE;
  float alpha = sin(w0) / (2.0f * q);
  float b0 = alpha, b1 = 0.0f, b2 = -alpha;
  float a0 = 1.0f + alpha, a1 = -2.0f * cos(w0), a2 = 1.0f - alpha;
  float out = (b0 / a0) * input + (b1 / a0) * z1[i] + (b2 / a0) * z2[i]
              - (a1 / a0) * z1[i] - (a2 / a0) * z2[i];
  z2[i] = z1[i];
  z1[i] = out;
  return out;
}

void setup() {
  pinMode(PWM_OUTPUT_PIN, OUTPUT);
  pinMode(TRIGGER_INPUT_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(SAMPLE_RATE);
  analogWriteRange(PWM_RES);
}

void loop() {
  float decay_time = 0.1f + (analogRead(POT1_PIN) / 1023.0f) * 2.9f;
  float character = analogRead(POT2_PIN) / 1023.0f;
  float modulation = analogRead(POT3_PIN) / 1023.0f;

  synth.env_step = 1.0f / (decay_time * SAMPLE_RATE);

  bool btn = !digitalRead(BUTTON_PIN);
  if (btn && !synth.last_btn && millis() - synth.last_btn_time > 100) {
    synth.mode = (synth.mode + 1) % 5;
    synth.last_btn_time = millis();
  }
  synth.last_btn = btn;

  bool trig = digitalRead(TRIGGER_INPUT_PIN);
  if (trig && !synth.last_trig) {
    synth.env = 1.0f;
    synth.form_phase[0] = synth.form_phase[1] = synth.form_phase[2] = 0.0f;
  }
  synth.last_trig = trig;

  if (synth.env > 0.0f) {
    synth.env -= synth.env_step;
    if (synth.env < 0.0f) synth.env = 0.0f;
  }

  digitalWrite(LED_PIN, synth.env > 0.05f ? HIGH : LOW);

  float output = 0.0f;

  if (synth.env > 0.001f) {
    float src = fast_noise();
    float q = 4.0f + modulation * 3.0f;

    switch (synth.mode) {
  case 0: // Turbulent gust
      {
        float sweep = 200.0f + character * 1800.0f + fast_noise() * 400.0f;
        float s1 = formant_bandpass(src, sweep, q, 0);
        output = s1 * 0.6f;
        break;
      }
  case 1: // Cutting pressure burst
      {
        float burst = src * (1.0f + modulation * 2.0f);
        float s1 = formant_bandpass(burst, 1500.0f + character * 1000.0f, q, 0);
        float s2 = formant_bandpass(burst, 3000.0f + modulation * 1000.0f, q, 1);
        output = (s1 + s2) * 0.4f;
        break;
      }
  case 2: // Infrasound rumble
      {
        float rumb = sinf(millis() * 0.001f * (10.0f + character * 30.0f)) * 0.5f + fast_noise() * 0.3f;
        output = rumb * (0.8f + modulation);
        break;
      }
  case 3: // Stratospheric swirl
      {
        float w1 = formant_bandpass(src, 800.0f + modulation * 3000.0f, q, 0);
        float w2 = formant_bandpass(src, 5000.0f + character * 1000.0f + fast_noise()*300.0f, q, 1);
        output = (w1 + w2) * 0.5f;
        break;
      }
  case 4: // Hell-suck gate flutter
      {
        float gate = ((millis() >> 5) & 1) ? 1.0f : -1.0f;
        float modsrc = src * gate;
        float s1 = formant_bandpass(modsrc, 400.0f + modulation * 2000.0f, q, 0);
        output = s1 * 0.6f;
        break;
      }
    }

    output += fast_noise() * 0.1f * modulation;
    output = tanh(output * (2.5f + character * 3.0f));

    if (modulation > 0.5f) {
      float crush = 4.0f + modulation * 12.0f;
      output = floorf(output * crush) / crush;
    }

    output *= synth.env;
  }

  int pwm = PWM_MID + (int)(output * PWM_MID);
  pwm = constrain(pwm, 0, PWM_RES - 1);
  analogWrite(PWM_OUTPUT_PIN, pwm);
  delayMicroseconds(45);
}
