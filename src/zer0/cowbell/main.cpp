/*
HAGIWO MOD2

zer0 Cowbell v1.0
TR-909 style cowbell using a small wavetable with metallic overtones.

-- Pin assignment --
POT1   A0   Brightness/Character
POT2   A1   Decay time
POT3   A2   Pitch/Frequency
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  (unused)
LED    GPIO5  Trigger indicator
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/


#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>

// === System Settings ===
const float SYS_CLK = 150000000.0f;
const float AUDIO_FS = SYS_CLK / 4096.0f; // ~36.6kHz
const uint16_t PWM_RES = 1023;
const float PWM_MID = PWM_RES / 2.0f;

// === Audio Parameters ===
const uint8_t WAVE_SIZE = 64;
float cowbellWave[WAVE_SIZE];

// === Pins ===
#define PWM_OUT_PIN   1
#define TRIG_PIN      7
#define ACCENT_PIN    0
#define LED_PIN       5
#define BUTTON_PIN    6  // Bell type selection button
#define POT1_PIN      A0 // Brightness
#define POT2_PIN      A1 // Decay
#define POT3_PIN      A2 // Pitch

// === State Variables ===
volatile bool playing = false;
volatile float env = 0.0f;
volatile float oscPhase = 0.0f;
volatile float oscFreq = 1000.0f;
volatile float decayRate = 0.995f;
volatile float brightness = 0.5f;
volatile float volFactor = 1.0f;
volatile bool reqTrig = false;
volatile uint8_t bellType = 0;  // 0=Classic, 1=Latin, 2=Agogo, 3=Synth

// PWM slices
uint sliceAudio, sliceTimer;

// Brightness tracking for wavetable updates
float lastBrightness = -1.0f;

// LED timing - follows the decay
volatile uint32_t ledOffTime = 0;
volatile bool ledFollowsDecay = false;  // LED follows audio decay

// Button handling for bell type selection
int lastButtonState = HIGH;

// === Update wavetable based on brightness and bell type ===
void updateCowbellWave(float brightness) {
    // Bell type specific harmonic content - more metallic edge
    float h3, h5;
    switch (bellType) {
        case 0: // Classic cowbell
            h3 = 0.3f + brightness * 0.7f;  // 0.3–1.0 (harder)
            h5 = 0.2f + brightness * 0.6f;  // 0.2–0.8 (harder)
            break;
        case 1: // Latin cowbell - more aggressive
            h3 = 0.4f + brightness * 0.8f;  // 0.4–1.2 (very aggressive)
            h5 = 0.3f + brightness * 0.8f;  // 0.3–1.1 (very aggressive)
            break;
        case 2: // Agogo bell - bright and cutting
            h3 = 0.5f + brightness * 0.7f;  // 0.5–1.2 (extremely sharp)
            h5 = 0.4f + brightness * 0.9f;  // 0.4–1.3 (extremely sharp)
            break;
        case 3: // Synth bell - complex harmonics
            h3 = 0.2f + brightness * 0.9f;  // 0.2–1.1 (wide range)
            h5 = 0.1f + brightness * 0.7f;  // 0.1–0.8 (more controllable)
            break;
        default:
            h3 = 0.3f + brightness * 0.7f;
            h5 = 0.2f + brightness * 0.6f;
            break;
    }
    
    float norm = 1.0f + h3 + h5;

    for (int i = 0; i < WAVE_SIZE; ++i) {
        float t = float(i) / WAVE_SIZE;
        
        if (bellType == 3) {
            // Synth bell: add 7th harmonic for complexity + 9th for extra bite
            cowbellWave[i] = (
                sinf(2 * PI * t) +
                h3 * sinf(2 * PI * t * 3) +
                h5 * sinf(2 * PI * t * 5) +
                (brightness * 0.3f) * sinf(2 * PI * t * 7) +
                (brightness * brightness * 0.2f) * sinf(2 * PI * t * 9)  // 9th harmonic
            ) / (norm + brightness * 0.3f + brightness * brightness * 0.2f);
        } else {
            cowbellWave[i] = (
                sinf(2 * PI * t) +
                h3 * sinf(2 * PI * t * 3) +
                h5 * sinf(2 * PI * t * 5)
            ) / norm;
        }
    }
}

// === Create synthetic TR-909 Cowbell waveform ===
void initCowbellWave() {
    // Initial waveform with default brightness
    updateCowbellWave(0.5f);
}

// === ISR: Audio generation ===
void on_pwm_wrap() {
    pwm_clear_irq(sliceTimer);

    if (!playing) {
        pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
    // LED off when no sound is playing
        if (ledFollowsDecay) {
            digitalWrite(LED_PIN, LOW);
            ledFollowsDecay = false;
        }
        return;
    }

    // Lookup current wavetable sample
    oscPhase += oscFreq / AUDIO_FS;
    if (oscPhase >= 1.0f) oscPhase -= 1.0f;

    int idx = int(oscPhase * WAVE_SIZE) % WAVE_SIZE;
    float sample = cowbellWave[idx];

    // Volume and envelope
    float val = sample * env * volFactor;

    env *= decayRate;
    if (env < 0.001f) {
        playing = false;
        env = 0.0f;
    // LED off when decay ends
        if (ledFollowsDecay) {
            digitalWrite(LED_PIN, LOW);
            ledFollowsDecay = false;
        }
    }

    // Scale to PWM range
    int32_t out = PWM_MID + int32_t(val * PWM_MID);
    if (out < 0) out = 0; else if (out > PWM_RES) out = PWM_RES;

    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, uint16_t(out));
}

// === Trigger ISR ===
void triggerISR() {
    volFactor = digitalRead(ACCENT_PIN) ? 0.6f : 1.0f;
    reqTrig = true;
    digitalWrite(LED_PIN, HIGH);
}

// === Setup ===
void setup() {
    analogReadResolution(10);
    randomSeed(analogRead(26)); // Noise source

    initCowbellWave();

    // === PWM Audio ===
    pinMode(PWM_OUT_PIN, OUTPUT);
    gpio_set_function(PWM_OUT_PIN, GPIO_FUNC_PWM);
    sliceAudio = pwm_gpio_to_slice_num(PWM_OUT_PIN);
    pwm_set_clkdiv(sliceAudio, 1.0f);
    pwm_set_wrap(sliceAudio, PWM_RES);
    pwm_set_enabled(sliceAudio, true);

    // === Timer PWM for ISR ===
    pinMode(2, OUTPUT);
    gpio_set_function(2, GPIO_FUNC_PWM);
    sliceTimer = pwm_gpio_to_slice_num(2);
    pwm_set_clkdiv(sliceTimer, 1.0f);
    pwm_set_wrap(sliceTimer, 4095);
    pwm_set_enabled(sliceTimer, true);
    pwm_clear_irq(sliceTimer);
    pwm_set_irq_enabled(sliceTimer, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    // === GPIO ===
    pinMode(TRIG_PIN, INPUT);
    pinMode(ACCENT_PIN, INPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);  // Button for bell type selection
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    attachInterrupt(digitalPinToInterrupt(TRIG_PIN), triggerISR, RISING);
}

// === Main Loop ===
void loop() {
    // LED auto-off only when not following the decay
    if (ledOffTime && millis() >= ledOffTime && !ledFollowsDecay) {
        digitalWrite(LED_PIN, LOW);
        ledOffTime = 0;
    }

    // === Button handling for bell type selection ===
    int buttonState = digitalRead(BUTTON_PIN);
    if (buttonState == LOW && lastButtonState == HIGH) {
        bellType = (bellType + 1) % 4;
        // Force wavetable update for new bell type
        lastBrightness = -1.0f;
        delay(100); // Simple debounce
    }
    lastButtonState = buttonState;

    // === Read potentiometers ===
    float pot1 = analogRead(POT1_PIN) / 1023.0f; // Brightness
    float pot2 = analogRead(POT2_PIN) / 1023.0f; // Decay
    float pot3 = analogRead(POT3_PIN) / 1023.0f; // Pitch

    brightness = pot1;
    
    // Update wavetable when brightness changes or bell type switches
    if (fabs(brightness - lastBrightness) > 0.01f) {
        updateCowbellWave(brightness);
        lastBrightness = brightness;
    }
    
    // Decay timing: 20–800 ms with a squarer curve for better control
    float decayMs = 20.0f + pot2 * pot2 * 780.0f;  // 20–800 ms
    decayRate = powf(0.001f, 1.0f / (decayMs * AUDIO_FS * 0.001f));
    
    // Pitch range varies by bell type
    switch (bellType) {
        case 0: // Classic: 800-1400 Hz
            oscFreq = 800.0f + pot3 * 600.0f;
            break;
        case 1: // Latin: higher pitch 900-1500 Hz
            oscFreq = 900.0f + pot3 * 600.0f;
            break;
        case 2: // Agogo: very high 1000-1800 Hz
            oscFreq = 1000.0f + pot3 * 800.0f;
            break;
        case 3: // Synth: wide range 600-1600 Hz
            oscFreq = 600.0f + pot3 * 1000.0f;
            break;
        default:
            oscFreq = 800.0f + pot3 * 600.0f;
            break;
    }

    // === Handle trigger ===
    if (reqTrig) {
        reqTrig = false;
        env = 1.0f;
        oscPhase = 0.0f;
        playing = true;
    // LED now follows the decay
        digitalWrite(LED_PIN, HIGH);
        ledFollowsDecay = true;
    ledOffTime = 0;  // No fixed timeout anymore
    }

    delayMicroseconds(500); // ≈1kHz loop
}