/*
HAGIWO MOD2

zer0 VoiceES v1.0
Formant/voice-like synth using simple band-pass formants and an envelope trigger.

-- Pin assignment --
POT1   A0   Decay time
POT2   A1   Character (formant color)
POT3   A2   Mod amount
IN1    GPIO7  Trigger
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>

// Pin definitions
#define PWM_PIN       1
#define TRIG_PIN      7
#define BUTTON_PIN    6
#define LED_PIN       5
#define POT_DECAY     A0
#define POT_CHAR      A1
#define POT_MOD       A2

#define SAMPLE_RATE  22050.0f
#define PWM_RES       1024
#define PWM_MID       (PWM_RES/2)
#define TWO_PI        6.28318530718f

struct Synth {
  float env = 0, env_step = 0;
  bool lastTrig = false, lastBtn = false;
  unsigned long lastBtnTime = 0;
  int mode = 0;
} synth;

uint32_t seed = 0xDEADBEEF;
float fastNoise(){
  seed = seed * 1664525 + 1013904223;
  return ((seed >> 16)&0xFFFF)/32768.0f - 1.0f;
}

// Simple band-pass formant filter
float bpf(float x, float f, float Q){
  static float z1=0, z2=0;
  float w0 = TWO_PI*f/SAMPLE_RATE;
  float alpha = sin(w0)/(2*Q);
  float b0 = alpha, b2 = -alpha;
  float a0 = 1+alpha, a1 = -2*cos(w0), a2 = 1-alpha;
  float y = (b0/a0)*x + ((b2)/a0)*z2 - (a1/a0)*z1 - (a2/a0)*z2;
  z2 = z1; z1 = y;
  return y;
}

void setup(){
  pinMode(PWM_PIN, OUTPUT);
  pinMode(TRIG_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(SAMPLE_RATE);
  analogWriteRange(PWM_RES);
}

void loop(){
  float decay = 0.05f + analogRead(POT_DECAY)/1023.0f*0.5f;
  float character = analogRead(POT_CHAR)/1023.0f;
  float mod = analogRead(POT_MOD)/1023.0f;

  synth.env_step = 1.0f/(decay*SAMPLE_RATE);

  // Mode switch on button
  bool btn = !digitalRead(BUTTON_PIN);
  if(btn && !synth.lastBtn && millis()-synth.lastBtnTime>100){
    synth.mode = (synth.mode+1)%3;
    synth.lastBtnTime = millis();
  }
  synth.lastBtn = btn;

  // Trigger envelope
  bool trig = digitalRead(TRIG_PIN);
  if(trig && !synth.lastTrig){
    synth.env = 1.0f;
  }
  synth.lastTrig = trig;

  if(synth.env>0){
    synth.env -= synth.env_step;
    if(synth.env<0) synth.env=0;
  }

  digitalWrite(LED_PIN, synth.env>0.1f ? HIGH:LOW );

  float x = 0;

  if(synth.env>0.001f){
  // Generate glottis-like pulses plus noise
    float pulse = (fastNoise()>0.5f)?1.0f:-1.0f;
    float noise = fastNoise()*0.6f;
    float src = pulse*0.8f + noise;

    // Dynamic formant frequencies
    float f1 = 300.0f + character*200.0f + sin(millis()*0.001f)*50.0f;
    float f2 = 1200.0f + character*800.0f + cos(millis()*0.0007f)*200.0f;
    float f3 = 2500.0f + mod*500.0f + fastNoise()*100.0f;

    // Formant filtering
    float y1 = bpf(src, f1, 5.0f);
    float y2 = bpf(src, f2, 6.0f);
    float y3 = bpf(src, f3, 4.0f);

    x = (y1+y2+y3)*0.3f;

    // Mode-specific behavior
    switch(synth.mode){
      case 0: // Whisper-like
        x *= 0.8f + mod*0.2f;
        break;
      case 1: // Broken voice with glitch
        if(mod>0.5f && ((millis()>>7)&1)) x = -x;
        x *= 1.2f;
        break;
      case 2: // Paranoia stutter
        if((millis()%(int)(50+mod*100))<10) x*=0.1f;
        x *= 1.0f;
        break;
    }

    x += noise*mod*0.1f;
    x = tanh(x*(2.0f + character*2.0f));
    if(mod>0.5f){
      float c = 4 + mod*20;
      x = floor(x*c)/c;
    }

    x *= synth.env;
  }

  int pwm = PWM_MID + (int)(x * PWM_MID);
  pwm = constrain(pwm, 0, PWM_RES-1);
  analogWrite(PWM_PIN, pwm);
  delayMicroseconds(45);
}
