/*
HAGIWO MOD2

zer0 Snare v1.0
TR-909 style snare with square+noise mix, 4 modes, accent, and LED.

-- Pin assignment --
POT1   A0   Pitch
POT2   A1   Mode-dependent parameter
POT3   A2   Mode-dependent parameter
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include <math.h>
#include <stdlib.h>

constexpr int TABLE_SIZE = 4096;
constexpr float TABLE_INV = 1.0f / (TABLE_SIZE - 1);

const float SYS_CLOCK = 150'000'000.0f;
const float NOTE_LEN = 0.3f;
const float BASE_INC = (TABLE_SIZE * 4096.0f) / (NOTE_LEN * SYS_CLOCK);
const float DT = NOTE_LEN / TABLE_SIZE;
const float FULL_SCALE = 1023.0f;
const float MID_LEVEL = FULL_SCALE / 2.0f;

bool editMode = false;
int snareMode = 0;  // 4 modes: 0=Classic, 1=Detune, 2=Punch, 3=Fat

volatile float pitch = 185.0f;          // Square base tone
volatile float detune = 1.04f;          // Detune of second square
volatile float brightness = 0.5f;       // Tone vs. noise mix
volatile float decayNoise = 0.06f;      // Noise decay
volatile float decayTone = 0.04f;       // Tone decay
volatile float masterGain = 1.0f;       // Master gain for Fat mode

volatile bool accentState = false;
volatile bool noteOn = false;
volatile float phase = 0.0f;
volatile bool reqTrig = false;

uint16_t finalTable[TABLE_SIZE];

uint sliceAudio;
uint sliceTimer;

// LED timing variables - coupled to decay
volatile bool ledState = false;
volatile uint32_t ledStartTime = 0;
volatile uint32_t ledDuration = 50000; // Dynamisch basierend auf Decay

void on_pwm_wrap() {
  pwm_clear_irq(sliceTimer);

  if (!noteOn) {
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
    return;
  }

  uint32_t i = (uint32_t)phase;
  float frac = phase - i;
  float y = finalTable[i] * (1.0f - frac) + finalTable[(i + 1) & (TABLE_SIZE - 1)] * frac;

  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)y);
  
  phase += BASE_INC;
  if (phase >= TABLE_SIZE) {
    noteOn = false;
    phase = 0.0f;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
  }
}

float bandpass(float x, float &s1, float &s2) {
  float hp = x - s1 + 0.995f * s2;
  s1 = x;
  s2 = hp;
  return hp;
}

void make_wavetable() {
  float phase1 = 0.0f;
  float phase2 = 0.0f;
  float envNoise = 1.0f;
  float envTone = 1.0f;

  float expNoise = expf(-DT / decayNoise);
  float expTone = expf(-DT / decayTone);

  float s1 = 0.0f, s2 = 0.0f;
  float prevWhite = 0.0f;

  for (int i = 0; i < TABLE_SIZE; ++i) {
    float f1 = pitch;
    float f2 = pitch * detune;
    phase1 += f1 * DT;
    phase2 += f2 * DT;
    if (phase1 >= 1.0f) phase1 -= 1.0f;
    if (phase2 >= 1.0f) phase2 -= 1.0f;
    
    float sq = ((phase1 < 0.5f) ? 1.0f : -1.0f) + ((phase2 < 0.5f) ? 1.0f : -1.0f);
    sq *= 0.5f * envTone;

    float white = ((float)rand() / RAND_MAX) * 2.0f - 1.0f;
    float blue = bandpass(white - prevWhite, s1, s2) * envNoise;
    prevWhite = white;

    float mix = brightness * sq + (1.0f - brightness) * blue;
    mix = mix * (accentState ? 0.5f : 1.0f) * masterGain;

    float out = MID_LEVEL + mix * (FULL_SCALE / 2.0f);
    if (out < 0) out = 0;
    if (out > FULL_SCALE) out = FULL_SCALE;

    finalTable[i] = (uint16_t)out;

    envTone *= expTone;
    envNoise *= expNoise;
  }
}

// HAGIWO-Standard Trigger ISR
void triggerISR() {
  accentState = digitalRead(0);  // Read accent state
  reqTrig = true;                // Set trigger request flag
  
  // LED on with dynamic duration based on decay
  digitalWrite(5, HIGH);
  ledState = true;
  ledStartTime = micros();
  // LED duration based on longer decay (20–300 ms)
  float maxDecay = max(decayNoise, decayTone);
  ledDuration = 20000 + (uint32_t)(maxDecay * 2000000.0f); // 20ms - 300ms
}

void setup() {
  Serial.begin(115200);
  Serial.println("Snare909 Starting...");
  
  // Initialize random seed for noise generation
  randomSeed(analogRead(26));
  
  // PWM Audio Setup
  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceTimer = pwm_gpio_to_slice_num(2);

  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, 1023);
  pwm_set_enabled(sliceAudio, true);

  pwm_set_clkdiv(sliceTimer, 1);
  pwm_set_wrap(sliceTimer, 4095);
  pwm_set_enabled(sliceTimer, true);

  pwm_clear_irq(sliceTimer);
  pwm_set_irq_enabled(sliceTimer, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  // Pin Setup (HAGIWO Standard)
  pinMode(7, INPUT);         // Trigger input
  pinMode(0, INPUT);         // Accent input  
  pinMode(6, INPUT_PULLUP);  // Button input
  pinMode(5, OUTPUT);        // LED output

  // HAGIWO-Standard Trigger Setup
  attachInterrupt(digitalPinToInterrupt(7), triggerISR, RISING);
  
  Serial.println("Snare909 Ready!");
}

void loop() {
  // LED auto-off with dynamic decay duration
  if (ledState && (micros() - ledStartTime) >= ledDuration) {
    digitalWrite(5, LOW);
    ledState = false;
  }

  // Handle trigger request (moved from ISR)
  if (reqTrig) {
    Serial.print("Trigger! Mode: "); Serial.println(snareMode);
    reqTrig = false;
    noteOn = true;
    phase = 0.0f;
    make_wavetable();  // Generate new wavetable outside ISR
  }

  // Button handling - cycle 4 modes
  bool button = !digitalRead(6);
  static bool lastBtn = false;
  if (!lastBtn && button) {
    snareMode = (snareMode + 1) % 4;  // 0→1→2→3→0
    Serial.print("Snare Mode: ");
    switch(snareMode) {
      case 0: Serial.println("CLASSIC"); break;
      case 1: Serial.println("DETUNE"); break;
      case 2: Serial.println("PUNCH"); break;
      case 3: Serial.println("FAT"); break;
    }
  }
  lastBtn = button;

  // A0 = Pitch (always active)
  int a0 = analogRead(A0);
  pitch = 150.0f + 150.0f * ((1023 - a0) / 1023.0f);

  // A1 & A2 depending on mode
  int a1 = analogRead(A1);
  int a2 = analogRead(A2);
  
  switch(snareMode) {
    case 0: { // CLASSIC - Brightness + Noise Decay
      brightness = (1023.0f - a1) / 1023.0f;
      decayNoise = 0.01f + 0.12f * ((1023 - a2) / 1023.0f);
      decayTone = 0.04f;  // Fixed
      detune = 1.04f;     // Fixed
      masterGain = 1.0f;  // Fixed
      break;
    }
      
    case 1: { // DETUNE - Detune + Tone Decay  
      detune = 1.00f + 0.08f * ((1023 - a1) / 1023.0f);
      decayTone = 0.005f + 0.095f * ((1023 - a2) / 1023.0f);
      brightness = 0.5f;   // Fixed
      decayNoise = 0.06f;  // Fixed
      masterGain = 1.0f;   // Fixed
      break;
    }
      
  case 2: { // PUNCH - tone/noise balance + combined decay
      brightness = (1023.0f - a1) / 1023.0f;
      float combinedDecay = 0.01f + 0.12f * ((1023 - a2) / 1023.0f);
      decayNoise = combinedDecay;
  decayTone = combinedDecay * 0.7f;  // Slightly shorter tone
  detune = 1.04f;     // Fixed
  masterGain = 1.2f;  // Slightly louder
      break;
    }
      
  case 3: { // FAT - brightness + master gain
      brightness = (1023.0f - a1) / 1023.0f;
      masterGain = 0.8f + 0.6f * ((1023 - a2) / 1023.0f);  // 0.8x - 1.4x
  decayNoise = 0.08f;  // Longer for fat sound
  decayTone = 0.06f;   // Longer for fat sound
  detune = 1.02f;      // Less detune for fat sound
      break;
    }
  }

  delayMicroseconds(500); // ≈1kHz loop rate
}
