/*
HAGIWO MOD2

zer0 Horn v1.0
Aggressive dubstep-style horn with 4 characters: Classic, Reese, FM, Growl.
PWM audio with IRQ-driven playback and LED feedback.

-- Pin assignment --
POT1   A0     Pitch
POT2   A1     Mod amount
POT3   A2     Drive
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include <math.h>
#include <stdlib.h>

constexpr int TABLE_SIZE = 4096;
constexpr float SYS_CLOCK = 150'000'000.0f;
constexpr float NOTE_LEN = 0.4f;
constexpr float BASE_INC = (TABLE_SIZE * 4096.0f) / (NOTE_LEN * SYS_CLOCK);
constexpr float DT = NOTE_LEN / TABLE_SIZE;
constexpr float FULL_SCALE = 1023.0f;
constexpr float MID_LEVEL = FULL_SCALE / 2.0f;

bool editMode = false;
int hornMode = 0;  // 0 = Classic, 1 = Reese, 2 = FM, 3 = Growl

volatile bool noteOn = false;
volatile float phase = 0.0f;
volatile bool reqTrig = false;
volatile bool accentState = false;

uint16_t finalTable[TABLE_SIZE];
uint sliceAudio;
uint sliceTimer;

volatile uint32_t horn_phase1 = 0;
volatile uint32_t horn_phase2 = 0;
volatile uint32_t horn_phase3 = 0;
volatile uint32_t lfo_phase = 0;

void on_pwm_wrap() {
  pwm_clear_irq(sliceTimer);

  if (!noteOn) {
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
    return;
  }

  uint32_t i = (uint32_t)phase;
  float frac = phase - i;
  float y = finalTable[i] * (1.0f - frac) + finalTable[(i + 1) & (TABLE_SIZE - 1)] * frac;

  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)y);
  phase += BASE_INC;
  if (phase >= TABLE_SIZE) {
    noteOn = false;
    phase = 0.0f;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
  }
}

float oscSaw(float phase) {
  return 2.0f * (phase - floor(phase + 0.5f));
}

float oscSin(float phase) {
  return sinf(2.0f * M_PI * phase);
}

float fastRandf() {
  return ((float)rand() / RAND_MAX) * 2.0f - 1.0f;
}

void make_wavetable(float baseFreq, float modAmt, float drive, float wobble) {
  float env = 1.0f;
  float decay = 0.9988f;  // Slightly slower decay for longer horns

  float phase1 = 0.0f, phase2 = 0.0f, phase3 = 0.0f;
  float lfoPhase = 0.0f;

  for (int i = 0; i < TABLE_SIZE; ++i) {
    float lfo = sinf(2.0f * M_PI * lfoPhase);
    lfoPhase += wobble * DT;
    if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;

    float sample = 0.0f;
    float freq = baseFreq;

    switch (hornMode) {
      case 0: { // Classic horn - aggressive wobble
        freq *= 1.0f + lfo * 0.8f;  // Higher wobble intensity
        phase1 += freq * DT;
        if (phase1 >= 1.0f) phase1 -= 1.0f;
        sample = oscSaw(phase1);
        // Add some sub-bass
        sample += oscSaw(phase1 * 0.5f) * 0.3f;
        break;
      }
      case 1: { // Reese bass - thicker via more detuning
        float f1 = freq * 0.99f;   // More detuning
        float f2 = freq * 1.01f;
        float f3 = freq;
        phase1 += f1 * DT;
        phase2 += f2 * DT;
        phase3 += f3 * DT;
        if (phase1 >= 1.0f) phase1 -= 1.0f;
        if (phase2 >= 1.0f) phase2 -= 1.0f;
        if (phase3 >= 1.0f) phase3 -= 1.0f;
        sample = (oscSaw(phase1) + oscSaw(phase2) + oscSaw(phase3)) / 3.0f;
        // Add slight pitch modulation
        sample *= (1.0f + lfo * 0.1f);
        break;
      }
      case 2: { // FM Skrillex - more brutal
        float modFreq = freq * 4.0f;  // Higher mod frequency
        phase2 += modFreq * DT;
        if (phase2 >= 1.0f) phase2 -= 1.0f;
        float mod = sinf(2.0f * M_PI * phase2) * modAmt;
  float carrierFreq = freq * (1.0f + mod + lfo * 0.5f);  // LFO also on carrier
        phase1 += carrierFreq * DT;
        if (phase1 >= 1.0f) phase1 -= 1.0f;
        sample = sinf(2.0f * M_PI * phase1);
  // Add some noise for glitch
        if (i % 100 == 0) sample += fastRandf() * 0.2f;
        break;
      }
      case 3: { // Growl - even dirtier
        float gmod = 1.0f + 1.2f * lfo;  // More growl modulation
        float f1 = freq * 0.4f * gmod;   // Lower for more growl
        float f2 = f1 * 2.1f;            // Inharmonic overtones
        float f3 = f1 * 3.3f;
        phase1 += f1 * DT;
        phase2 += f2 * DT;
        phase3 += f3 * DT;
        if (phase1 >= 1.0f) phase1 -= 1.0f;
        if (phase2 >= 1.0f) phase2 -= 1.0f;
        if (phase3 >= 1.0f) phase3 -= 1.0f;
        sample = oscSin(phase1) * 0.8f + oscSaw(phase2) * 0.15f + oscSaw(phase3) * 0.05f;
        break;
      }
    }

  // Nicer distortion
    sample *= env;
  sample = tanhf(sample * drive * 0.5f) * 1.2f;  // Softer clipping then boost
    sample *= (accentState ? 0.6f : 1.0f);

  float out = MID_LEVEL + sample * (FULL_SCALE * 0.45f);  // Slightly more headroom
    if (out < 0) out = 0;
    if (out > FULL_SCALE) out = FULL_SCALE;

    finalTable[i] = (uint16_t)out;
    env *= decay;
  }
}

void triggerISR() {
  accentState = digitalRead(0);
  reqTrig = true;
  digitalWrite(5, HIGH);
}

void setup() {
  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceTimer = pwm_gpio_to_slice_num(2);

  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, 1023);
  pwm_set_enabled(sliceAudio, true);

  pwm_set_clkdiv(sliceTimer, 1);
  pwm_set_wrap(sliceTimer, 4095);
  pwm_set_enabled(sliceTimer, true);

  pwm_clear_irq(sliceTimer);
  pwm_set_irq_enabled(sliceTimer, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  pinMode(7, INPUT);
  pinMode(0, INPUT);
  pinMode(6, INPUT_PULLUP);
  pinMode(5, OUTPUT);

  attachInterrupt(digitalPinToInterrupt(7), triggerISR, RISING);
}

void loop() {
  if (reqTrig) {
    reqTrig = false;
    noteOn = true;
    phase = 0.0f;

    float potPitch = analogRead(A0);
    float potMod = analogRead(A1);
    float potDrive = analogRead(A2);

    // Better frequency range for bass (30–150 Hz)
    float baseFreq = 30.0f + 120.0f * (potPitch / 1023.0f);
    
    // More aggressive modulation per mode
    float modAmt, drive, wobble;
    switch(hornMode) {
  case 0: // Classic - wobble focus
        modAmt = 0.2f + 1.5f * (potMod / 1023.0f);
        wobble = 1.0f + 15.0f * (potMod / 1023.0f);  // 1-16 Hz
        drive = 2.0f + 8.0f * (potDrive / 1023.0f);   // Mehr Drive
        break;
  case 1: // Reese - moderate
        modAmt = 0.1f + 0.8f * (potMod / 1023.0f);
        wobble = 0.3f + 3.0f * (potMod / 1023.0f);    // Langsamer
        drive = 1.5f + 4.0f * (potDrive / 1023.0f);
        break;
  case 2: // FM - extreme
        modAmt = 0.5f + 5.0f * (potMod / 1023.0f);    // Viel FM
        wobble = 2.0f + 20.0f * (potMod / 1023.0f);   // Schnell
        drive = 3.0f + 10.0f * (potDrive / 1023.0f);  // Brutal
        break;
  case 3: // Growl - heavy
        modAmt = 0.3f + 2.0f * (potMod / 1023.0f);
        wobble = 0.5f + 8.0f * (potMod / 1023.0f);    // Medium
        drive = 4.0f + 12.0f * (potDrive / 1023.0f);  // Sehr heavy
        break;
    }

    make_wavetable(baseFreq, modAmt, drive, wobble);
    
  // LED stays on longer depending on mode
    digitalWrite(5, HIGH);
  delay(50 + hornMode * 25);  // 50–125 ms depending on mode
    digitalWrite(5, LOW);
  }

  bool button = !digitalRead(6);
  static bool lastBtn = false;
  if (!lastBtn && button) {
    hornMode = (hornMode + 1) % 4;
    
    // LED feedback for mode switch
    for(int i = 0; i <= hornMode; i++) {
      digitalWrite(5, HIGH);
      delay(100);
      digitalWrite(5, LOW);
      delay(100);
    }
  }
  lastBtn = button;

  delay(2);
}
