/*
HAGIWO MOD2

zer0 Death Whistle v1.0
Aztec death-whistle-inspired noise beast with chaotic LFOs and modes.

-- Pin assignment --
POT1   A0   Decay time
POT2   A1   Character/Chaos
POT3   A2   Modulation/Instability
IN1    GPIO7  Trigger
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Mode select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>

// HAGIWO MOD2 Pin assignment
#define PWM_OUTPUT_PIN 1
#define TRIGGER_INPUT_PIN 7
#define BUTTON_PIN 6
#define LED_PIN 5
#define POT1_PIN A0  // Decay Time
#define POT2_PIN A1  // Character/Chaos
#define POT3_PIN A2  // Modulation/Instability

#define SAMPLE_RATE 22050.0f
#define PWM_RES 1024
#define PWM_MID (PWM_RES / 2)

struct DeathWhistle {
  float env = 0.0f;
  float env_step = 0.0f;
  float phase1 = 0.0f, phase2 = 0.0f, phase3 = 0.0f;
  float mod_phase = 0.0f;
  float chaos_phase = 0.0f;
  bool last_trig = false;
  bool last_btn = false;
  unsigned long last_btn_time = 0;
  int mode = 0;
} whistle;

uint32_t noise_seed = 0xACE1;
float fast_noise() {
  noise_seed = noise_seed * 1664525 + 1013904223;
  return ((noise_seed >> 16) & 0xFFFF) / 32768.0f - 1.0f;
}

float hard_clip(float x, float threshold = 0.7f) {
  if (x > threshold) return threshold;
  if (x < -threshold) return -threshold;
  return x;
}

float saw_wave(float phase) {
  return (2.0f * phase / (2.0f * PI)) - 1.0f;
}

void setup() {
  pinMode(PWM_OUTPUT_PIN, OUTPUT);
  pinMode(TRIGGER_INPUT_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(SAMPLE_RATE);
  analogWriteRange(PWM_RES);
}

void loop() {
  float decay_time = 0.1f + (analogRead(POT1_PIN) / 1023.0f) * 2.9f;
  float character = analogRead(POT2_PIN) / 1023.0f;
  float modulation = 1.0f - (analogRead(POT3_PIN) / 1023.0f);  // Inverted: left=1.0, right=0.0

  float pitch = 300.0f + character * character * 1700.0f;
  float harmonic_chaos = character * 2.0f;
  float feedback = character * 0.8f;

  whistle.mod_phase += (2.0f * PI * (1.0f + modulation * 8.0f)) / SAMPLE_RATE;
  whistle.chaos_phase += (2.0f * PI * (0.3f + modulation * 3.7f)) / SAMPLE_RATE;
  if (whistle.mod_phase >= 2.0f * PI) whistle.mod_phase -= 2.0f * PI;
  if (whistle.chaos_phase >= 2.0f * PI) whistle.chaos_phase -= 2.0f * PI;

  // Almost random LFO 1: Sample & Hold + drift
  static float lfo1_hold = 0.0f;
  static int lfo1_counter = 0;
  lfo1_counter++;
  if (lfo1_counter > (int)(50 + fast_noise() * 100)) {  // Random hold times
    lfo1_hold = fast_noise();
    lfo1_counter = 0;
  }
  float lfo1_drift = fast_noise() * 0.1f;  // Constant small drift
  float lfo1 = lfo1_hold + lfo1_drift;
  
  // Almost random LFO 2: chaotic jumps + noise bursts  
  static float lfo2_value = 0.0f;
  static int lfo2_counter = 0;
  lfo2_counter++;
  if (lfo2_counter > (int)(30 + character * 80)) {  // Character affects jump rate
    lfo2_value = fast_noise() * (0.8f + modulation * 1.2f);  // Random jumps
    lfo2_counter = 0;
  }
  float lfo2_noise = fast_noise() * 0.15f;  // Constant noise
  float lfo2 = lfo2_value + lfo2_noise;
  
  float noise_mod = fast_noise() * modulation;

  whistle.env_step = 1.0f / (decay_time * SAMPLE_RATE);

  bool btn = !digitalRead(BUTTON_PIN);
  if (btn && !whistle.last_btn && millis() - whistle.last_btn_time > 100) {
    whistle.mode = (whistle.mode + 1) % 4;
    whistle.last_btn_time = millis();
  }
  whistle.last_btn = btn;

  bool trig = digitalRead(TRIGGER_INPUT_PIN);
  if (trig && !whistle.last_trig) {
    whistle.env = 1.0f;
    whistle.phase1 = whistle.phase2 = whistle.phase3 = 0.0f;
  }
  whistle.last_trig = trig;

  if (whistle.env > 0.0f) {
    whistle.env -= whistle.env_step;
    if (whistle.env < 0.0f) whistle.env = 0.0f;
  }

  digitalWrite(LED_PIN, whistle.env > 0.05f ? HIGH : LOW);

  float output = 0.0f;

  if (whistle.env > 0.001f) {
    float pitch_mod = pitch * (1.0f + lfo1 * modulation * 0.1f + noise_mod * 0.05f);
    whistle.phase1 += (pitch_mod * 2.0f * PI) / SAMPLE_RATE;
    whistle.phase2 += (pitch_mod * (2.3f + harmonic_chaos * 1.2f + lfo2 * modulation * 0.3f) * 2.0f * PI) / SAMPLE_RATE;
    whistle.phase3 += (pitch_mod * (0.7f + harmonic_chaos * 0.8f + lfo1 * modulation * 0.2f) * 2.0f * PI) / SAMPLE_RATE;

    if (whistle.phase1 >= 2.0f * PI) whistle.phase1 -= 2.0f * PI;
    if (whistle.phase2 >= 2.0f * PI) whistle.phase2 -= 2.0f * PI;
    if (whistle.phase3 >= 2.0f * PI) whistle.phase3 -= 2.0f * PI;

    float s1 = sinf(whistle.phase1);
    float s2 = sinf(whistle.phase2);
    float s3 = sinf(whistle.phase3);

    float sq1 = (whistle.phase1 < PI) ? 1.0f : -1.0f;
    float sq2 = (whistle.phase2 < PI) ? 1.0f : -1.0f;
    float saw1 = saw_wave(whistle.phase1);
    float saw2 = saw_wave(whistle.phase2);

    float noise = fast_noise();
    float harsh_noise = hard_clip(noise * 3.0f, 0.8f);

    switch (whistle.mode) {
      case 0:
        output = (sq1 * 0.4f + saw1 * 0.3f + 
                 hard_clip(s2 * (2.5f + character + lfo1 * modulation), 0.6f) * 0.5f + 
                 s3 * (0.2f + harmonic_chaos * 0.3f) + 
                 harsh_noise * (0.3f + modulation * 0.4f + feedback * 0.2f)) * 0.9f;
        break;

      case 1: // Wind/Steam - less noise, more harmonic content
        output = (saw2 * (0.5f + character * 0.4f) + 
                 s1 * (0.4f + harmonic_chaos * 0.3f) +
                 hard_clip(s2 * s3 * (2.0f + feedback), 0.5f) * 0.6f +
                 harsh_noise * (0.2f + modulation * 0.3f)) * 1.0f;
        break;

      case 2:
        output = (sq1 * (0.6f + character * 0.4f) +
                 sq2 * (0.4f + lfo1 * modulation * 0.5f) +
                 harsh_noise * (0.4f + modulation * 0.6f + lfo1 * 0.3f) +
                 hard_clip(saw1 * (2.0f + feedback + lfo2 * modulation), 0.4f) * 0.3f) * 0.8f;
        break;

      case 3:
        float tremolo = 1.0f + lfo1 * (0.4f + harmonic_chaos * 0.5f + modulation * 0.6f);
        output = (sq1 * 0.3f + saw1 * 0.3f + hard_clip(s2, 0.6f) * 0.4f + s3 * 0.2f + 
                 harsh_noise * (0.2f + modulation * 0.4f) + 
                 lfo2 * modulation * 0.3f) * tremolo * 0.7f;
        break;
    }

    output *= whistle.env * (0.9f + modulation * 1.3f + lfo1 * 0.4f);

    output = hard_clip(output * (2.5f + character * 2.0f), 0.8f);
    output = tanh(output * 1.8f);

    if (modulation > 0.5f) {
      float crush_factor = 8.0f + modulation * 16.0f;
      output = floorf(output * crush_factor) / crush_factor;
    }

  // --- BRUTAL PATCH START ---
    float feedback_signal = output * feedback * 0.6f;
    output += feedback_signal;

    int xor_noise = ((int)(whistle.phase1 * 1000) ^ (int)(whistle.phase2 * 800)) & 0xFF;
    float digital_noise = ((xor_noise / 128.0f) - 1.0f) * (modulation * 0.5f);
    output += digital_noise;

    output = fabsf(fmodf(output + 1.0f, 4.0f) - 2.0f) - 1.0f;

    if (fmodf(whistle.mod_phase, 2.0f * PI) < modulation * PI)
        output *= -1.0f;

    output = copysignf(powf(fabsf(output), 1.5f + modulation), output);
  // --- BRUTAL PATCH END ---
  }

  int pwm = PWM_MID + (int)(output * PWM_MID * 0.9f);
  if (pwm < 0) pwm = 0;
  if (pwm >= PWM_RES) pwm = PWM_RES - 1;
  analogWrite(PWM_OUTPUT_PIN, pwm);

  delayMicroseconds(45);
}
