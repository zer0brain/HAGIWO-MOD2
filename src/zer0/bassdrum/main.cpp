/*
HAGIWO MOD2

zer0 BD909 Drum v1.0
TR-909 style bass drum with selectable character (Classic, Deep, Tight, Sub), accent input, and trigger LED.
Button cycles character. LED lights up on trigger. Accent is activated via IN2 (GPIO0).

-- Pin assignment --
POT1   A0   Pitch
POT2   A1   Decay
POT3   A2   Character select
IN1    D7   Trigger input
IN2    D0   Accent input (HIGH = accent)
OUT    D1   Audio output (PWM)
BUTTON D6   Character select
LED    D5   Trigger indicator
EEPROM Not used

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"

// --- Pin assignment ---
#define PWM_OUTPUT_PIN 1     // Audio output (PWM)
#define TRIGGER_INPUT_PIN 7  // Trigger input
#define ACCENT_INPUT_PIN 0   // Accent input
#define BUTTON_PIN 6         // Character selection button
#define LED_PIN 5            // Trigger LED
#define POT1_PIN A0          // Pitch
#define POT2_PIN A1          // Decay
#define POT3_PIN A2          // Character select

// Audio and synthesis parameters
#define SAMPLE_RATE 45454        // ~45kHz for real-time audio
#define UPDATE_RATE_US 22        // 45.45kHz update rate

// --- 909-typical parameter ranges ---
#define BD_BASE_FREQ_MIN 35.0f   // 909: ca. 35 Hz
#define BD_BASE_FREQ_MAX 60.0f   // 909: ca. 60 Hz
#define BD_DECAY_MIN 0.05f       // 50 ms
#define BD_DECAY_MAX 0.4f        // 400 ms

// Kick drum synthesis state
volatile uint32_t kick_phase = 0;
volatile uint32_t env_phase = 0;
volatile bool kick_active = false;
volatile bool last_gate_state = false;
volatile uint8_t kick_character = 0;
volatile uint16_t kick_timer = 0;

// Control state
volatile bool btn_pressed = false;
volatile bool last_btn_state = false;
volatile unsigned long last_btn_time = 0;

// --- PWM ISR for audio ---
volatile bool bd_playing = false;
volatile float bd_env = 0.0f;
volatile float bd_decay = 0.2f;
volatile float bd_pitch = 0.5f;
volatile float bd_accent = 1.0f;
volatile uint32_t bd_phase = 0;
volatile uint16_t bd_timer = 0;

#define PWM_FS 1023.0f
#define PWM_MID (PWM_FS / 2.0f)

void on_pwm_wrap() {
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    pwm_clear_irq(slice);
    if (!bd_playing) {
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
        digitalWrite(LED_PIN, LOW);
        return;
    }
    // 909 bass drum synthesis
    bd_timer++;
    float base_freq = BD_BASE_FREQ_MIN + bd_pitch * (BD_BASE_FREQ_MAX - BD_BASE_FREQ_MIN);
    float decay_time = BD_DECAY_MIN + bd_decay * (BD_DECAY_MAX - BD_DECAY_MIN);
    float accent_mult = 1.0f + bd_accent;
    float pitch_env = 2.0f * expf(-bd_timer * 1.0f / (decay_time * SAMPLE_RATE));
    float current_freq = base_freq * (1.0f + pitch_env);
    // Proper phase increment calculation
    uint32_t phase_inc = (uint32_t)(current_freq * 4294967296.0f / SAMPLE_RATE);
    bd_phase += phase_inc;
    // Proper sine using 32-bit phase (0…2π)
    int16_t osc = (int16_t)(sinf((float)bd_phase * 6.283185307179586f / 4294967296.0f) * 500);
    // Gentle envelope ramp-up
    float ramp = (bd_timer < 8) ? (bd_timer / 8.0f) : 1.0f;
    float amp_env = expf(-bd_timer * 1.0f / (decay_time * SAMPLE_RATE)) * ramp;
    float out = osc * amp_env * accent_mult;
    if (amp_env < 0.001f) {
        bd_playing = false;
        bd_env = 0.0f;
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
        digitalWrite(LED_PIN, LOW);
        return;
    }
    int val = (int)(out + PWM_MID);
    if (val < 0) val = 0;
    if (val > PWM_FS) val = (int)PWM_FS;
    pwm_set_chan_level(slice, PWM_CHAN_B, val);
}

void onTrig() {
    bd_accent = analogRead(ACCENT_INPUT_PIN) / 1023.0f;
    bd_pitch = analogRead(POT1_PIN) / 1023.0f;
    bd_decay = analogRead(POT2_PIN) / 1023.0f;
    bd_playing = true;
    bd_timer = 0;
    bd_phase = 0;
    bd_env = 0.0f;
    pwm_set_chan_level(pwm_gpio_to_slice_num(PWM_OUTPUT_PIN), PWM_CHAN_B, (uint16_t)PWM_MID);
    digitalWrite(LED_PIN, HIGH);
}

void setup() {
    // Configure HAGIWO MOD2 hardware
    pinMode(POT1_PIN, INPUT);
    pinMode(POT2_PIN, INPUT);
    pinMode(POT3_PIN, INPUT);
    pinMode(ACCENT_INPUT_PIN, INPUT);
    pinMode(PWM_OUTPUT_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);
    // PWM init similar to hihat909, without switching to INPUT
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    gpio_set_function(PWM_OUTPUT_PIN, GPIO_FUNC_PWM);
    pwm_set_clkdiv_int_frac(slice, 4, 0);
    pwm_set_wrap(slice, (uint16_t)PWM_FS);
    pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    pwm_set_enabled(slice, true);
    pwm_clear_irq(slice);
    pwm_set_irq_enabled(slice, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);
    pinMode(TRIGGER_INPUT_PIN, INPUT);
    pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    digitalWrite(LED_PIN, LOW);
}

void loop() {
    // Trigger polling similar to hihat909
    static int last_trig = LOW;
    int trig = digitalRead(TRIGGER_INPUT_PIN);
    if (trig == HIGH && last_trig == LOW) {
        onTrig();
    }
    last_trig = trig;
    // Button cycles character
    static int last_button = HIGH;
    int button = digitalRead(BUTTON_PIN);
    if (button == LOW && last_button == HIGH) {
        kick_character = (kick_character + 1) % 4;
        delay(100);
    }
    last_button = button;
    // Character-specific parameter mappings
    float pitch_pot = analogRead(POT1_PIN) / 1023.0f;
    float decay_pot = analogRead(POT2_PIN) / 1023.0f;
    float accent_pot = analogRead(ACCENT_INPUT_PIN) / 1023.0f;
    switch (kick_character) {
        case 0: // Classic
            bd_pitch = 0.4f + pitch_pot * 0.4f; // 35-51 Hz
            bd_decay = 0.15f + decay_pot * 0.15f; // 65-250 ms
            bd_accent = accent_pot * 1.0f; // 1.0-2.0x
            break;
        case 1: // Deep
            bd_pitch = 0.3f + pitch_pot * 0.3f; // 35-53 Hz
            bd_decay = 0.25f + decay_pot * 0.15f; // 250-400 ms
            bd_accent = 0.5f + accent_pot * 0.8f; // 1.0-1.8x
            break;
        case 2: // Tight
            bd_pitch = 0.5f + pitch_pot * 0.4f; // 45-60 Hz
            bd_decay = 0.05f + decay_pot * 0.10f; // 50-150 ms
            bd_accent = accent_pot * 0.7f; // 1.0-1.7x
            break;
        case 3: // Sub
            bd_pitch = 0.2f + pitch_pot * 0.3f; // 35-44 Hz
            bd_decay = 0.30f + decay_pot * 0.10f; // 300-400 ms
            bd_accent = 0.7f + accent_pot * 0.5f; // 1.0-1.5x
            break;
    }
    delay(5);
}
