/*
HAGIWO MOD2

zer0 Rimshot v1.0
TR-909 style rimshot with tone+noise layers, 4 characters, accent, and LED.

-- Pin assignment --
POT1   A0   Pitch
POT2   A1   Decay
POT3   A2   Character
IN1    GPIO7  Trigger
IN2    GPIO0  Accent
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Character select
LED    GPIO5  Trigger LED
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <stdlib.h>

// --- Pin assignment (HAGIWO-Standard) ---
#define PWM_OUTPUT_PIN 1     // Audio out (PWM B)
#define TRIGGER_INPUT_PIN 7  // Trigger in (D7)
#define ACCENT_INPUT_PIN 0   // Accent in (D0)
#define BUTTON_PIN 6         // Character button (D6)
#define LED_PIN 5            // Trigger LED (D5)
#define POT1_PIN A0          // Pitch
#define POT2_PIN A1          // Decay
#define POT3_PIN A2          // Character

// Synth parameter ranges (rimshot-specific, intentionally wide)
#define RS_BASE_FREQ_MIN 200.0f   // 200 Hz
#define RS_BASE_FREQ_MAX 3000.0f  // 3 kHz (very wide)
#define RS_DECAY_MIN 0.005f       // 5 ms
#define RS_DECAY_MAX 0.12f        // 120 ms
#define RS_NOISE_MIX_MIN 0.1f
#define RS_NOISE_MIX_MAX 0.99f

#define SAMPLE_RATE 45454
#define PWM_FS 1023.0f
#define PWM_MID (PWM_FS / 2.0f)

volatile bool rs_playing = false;
volatile float rs_env = 0.0f;
volatile float rs_decay = 0.04f;
volatile float rs_pitch = 0.2f;
volatile float rs_accent = 1.0f;
volatile float rs_noise_mix = 0.5f;
volatile uint32_t rs_phase = 0;
volatile uint16_t rs_timer = 0;
volatile uint8_t rs_character = 0;

void on_pwm_wrap() {
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    pwm_clear_irq(slice);
    if (!rs_playing) {
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
        digitalWrite(LED_PIN, LOW);
        return;
    }
    rs_timer++;
    // Base frequency from pitch; accent and character shape tone
    float base_freq = RS_BASE_FREQ_MIN + rs_pitch * (RS_BASE_FREQ_MAX - RS_BASE_FREQ_MIN);
    float decay_time = RS_DECAY_MIN + rs_decay * (RS_DECAY_MAX - RS_DECAY_MIN);
    float accent_mult = 1.0f + 0.7f * rs_accent;

    // Character-specific settings
    float pitch_mul = 1.0f, noise_mix = rs_noise_mix, tone_mul = 1.0f;
    switch (rs_character) {
    case 0: // Classic: standard rimshot
            pitch_mul = 1.0f; noise_mix = 0.42f; tone_mul = 1.0f; break;
    case 1: // Hard: higher pitch, short, little noise
            pitch_mul = 1.55f; noise_mix = 0.21f; tone_mul = 1.2f; break;
    case 2: // Tight: high, very short, maximum noise
            pitch_mul = 2.1f; noise_mix = 0.82f; tone_mul = 1.8f; break;
    case 3: // Extreme/Glitch: very high, randomized decay, broken/glitchy
            pitch_mul = 2.9f; noise_mix = 0.97f; tone_mul = 2.4f;
            decay_time *= (0.5f + 0.5f * ((float)rand() / RAND_MAX)); break;
    }
    float freq = base_freq * pitch_mul;
    float amp_env = expf(-rs_timer * 1.0f / (decay_time * SAMPLE_RATE));
    float env_mod = amp_env * accent_mult * tone_mul;

    // Sine instead of square for a nicer sweet spot
    rs_phase += (uint32_t)(freq * 4294967296.0f / SAMPLE_RATE);
    float osc = sinf((float)rs_phase * 6.283185307179586f / 4294967296.0f);
    float noise = ((float)rand() / RAND_MAX) * 2.0f - 1.0f; // -1 ... 1
    float mix = (1.0f - noise_mix) * osc + noise_mix * noise;
    float out = mix * env_mod * (PWM_FS/2.0f);
    int val = (int)(out + PWM_MID);

    if (amp_env < 0.001f) {
        rs_playing = false;
        pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
        digitalWrite(LED_PIN, LOW);
        return;
    }
    if (val < 0) val = 0;
    if (val > PWM_FS) val = (int)PWM_FS;
    pwm_set_chan_level(slice, PWM_CHAN_B, val);
}

void onTrig() {
    rs_accent = analogRead(ACCENT_INPUT_PIN) / 1023.0f;
    rs_pitch = analogRead(POT1_PIN) / 1023.0f;
    rs_decay = analogRead(POT2_PIN) / 1023.0f;
    rs_noise_mix = analogRead(POT3_PIN) / 1023.0f;
    rs_playing = true;
    rs_timer = 0;
    rs_phase = 0;
    rs_env = 0.0f;
    digitalWrite(LED_PIN, HIGH);
}

void setup() {
    pinMode(POT1_PIN, INPUT);
    pinMode(POT2_PIN, INPUT);
    pinMode(POT3_PIN, INPUT);
    pinMode(ACCENT_INPUT_PIN, INPUT);
    pinMode(PWM_OUTPUT_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);
    uint slice = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    gpio_set_function(PWM_OUTPUT_PIN, GPIO_FUNC_PWM);
    pwm_set_clkdiv_int_frac(slice, 4, 0);
    pwm_set_wrap(slice, (uint16_t)PWM_FS);
    pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    pwm_set_enabled(slice, true);
    pwm_clear_irq(slice);
    pwm_set_irq_enabled(slice, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);
    pinMode(TRIGGER_INPUT_PIN, INPUT);
    pwm_set_chan_level(slice, PWM_CHAN_B, (uint16_t)PWM_MID);
    digitalWrite(LED_PIN, LOW);
    randomSeed(analogRead(3));
}

void loop() {
    static int last_trig = LOW;
    int trig = digitalRead(TRIGGER_INPUT_PIN);
    if (trig == HIGH && last_trig == LOW) {
        onTrig();
    }
    last_trig = trig;
    static int last_button = HIGH;
    int button = digitalRead(BUTTON_PIN);
    if (button == LOW && last_button == HIGH) {
        rs_character = (rs_character + 1) % 4;
        delay(120);
    }
    last_button = button;
    delay(3);
}
