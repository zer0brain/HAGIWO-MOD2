/*
HAGIWO MOD2

zer0 Tape Sampler v1.0
Cassette-style micro sampler with two samples, tape-typical LoFi effects, and glitch/crash simulation.

- Button cycles through available samples. LED blinks on playback.
- Trigger input starts playback from the beginning of the selected sample.
- POT1 (A0): Bitcrush/LoFi (fewer bits = more artifacts)
- POT2 (A1): Tape crash/glitch (higher = more dropouts/stutter)
- POT3 (A2): Wow/Flutter intensity (higher = more pitch wobble)
- LED (D2): Playback indicator
- IN1 (D7): Trigger input (rising edge)
- BUTTON (D6): Sample select
- OUT (D1): Audio output (PWM)

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include "hardware/pwm.h"
#include "hardware/irq.h"
#include <math.h>
#include <stdint.h>

// --- Include your sample data headers here ---
#include "sample1_data.h"
#include "sample2_data.h"

// --- Pin assignment ---
#define PWM_OUTPUT_PIN 1
#define TRIGGER_INPUT_PIN 7
#define BUTTON_PIN 6 
#define POT_LOFI_PIN A0      // POT1: Bitcrush/LoFi
#define POT_CRASH_PIN A1     // POT2: Tape crash/glitch
#define POT_WOW_PIN A2       // POT3: Wow/Flutter intensity
#define LED_PIN 2            // Playback indicator

#define PWM_FS 1023.0f
#define PWM_MID (PWM_FS / 2.0f)
const float SYSTEM_CLOCK_HZ = 150000000.0f;
const float PLAYBACK_SAMPLE_RATE = SYSTEM_CLOCK_HZ / (4.0f * (PWM_FS + 1.0f));

// --- Sample Structure & Data ---
struct Sample {
    const int16_t* data;
    uint32_t len;
    uint32_t original_rate;
    const char* name;
};
const Sample available_samples[] = {
    {sample1_data, sample1_data_len, sample1_original_rate, "Sample 1"},
    {sample2_data, sample2_data_len, sample2_original_rate, "Sample 2"}
};
const int NUM_SAMPLES = sizeof(available_samples) / sizeof(available_samples[0]);

// --- Playback State ---
volatile bool playing = false;
volatile float playback_fidx = 0.0f;
volatile int current_sample_idx = 0;

// --- Tape FX state ---
volatile int bitcrush_bits = 12;      // 12 = fast, clean; 2 = LoFi
volatile float wow_depth = 0.0f;      // 0 = none, 0.05 = strong
volatile float wow_phase = 0.0f;
volatile float wow_rate = 0.7f;       // Hz, fest
volatile float crash_chance = 0.0f;   // 0 = nie, 1 = immer
volatile bool crash_active = false;
volatile int crash_counter = 0;

// --- Debouncing Globals ---
volatile unsigned long last_trigger_time = 0;
const unsigned long debounce_delay = 20; // ms
int last_button_state = HIGH;
unsigned long last_button_press_time = 0;

// --- Tape noise & saturation ---
const float HISS_LEVEL_TAPE = 0.01f;     // Tape hiss
const float SATURATION_DRIVE_TAPE = 1.8f;// Tape saturation
const float LPF_ALPHA_TAPE = 0.65f;      // High-cut amount

// --- PWM Interrupt Service Routine ---
void on_pwm_wrap() {
    uint slice_num = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    pwm_clear_irq(slice_num);

    static float lpf_state_tape = 0.0f;
    static uint32_t tape_noise_seed = 12345;

    if (!playing) {
        pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
        lpf_state_tape = 0.0f;
        return;
    }

    const Sample* current_s = &available_samples[current_sample_idx];
    uint32_t idx0 = (uint32_t)playback_fidx;

    // --- Tape crash/glitch: dropout/stutter ---
    if (crash_chance > 0.01f && !crash_active && random(0, 1000) < (int)(crash_chance * 1000.0f)) {
        crash_active = true;
    crash_counter = random(10, 80); // 10–80 samples dropout
    }
    if (crash_active) {
        crash_counter--;
        if (crash_counter <= 0) crash_active = false;
    // During crash: either freeze (stutter) or zero (dropout)
    // Here: dropout (silence)
        pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
        playback_fidx += 1.0f; // trotzdem weiterlaufen
        return;
    }

    if (idx0 >= current_s->len - 1) {
        playing = false;
        digitalWrite(LED_PIN, LOW);
        pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
        lpf_state_tape = 0.0f;
        return;
    }

    // --- Wow/Flutter: Pitch wobble ---
    wow_phase += wow_rate / PLAYBACK_SAMPLE_RATE;
    if (wow_phase > 1.0f) wow_phase -= 1.0f;
    float wow_lfo = sinf(wow_phase * 2.0f * PI) * wow_depth;

    // --- Interpolation with Wow/Flutter ---
    float frac = playback_fidx - idx0;
    int16_t s0 = current_s->data[idx0];
    int16_t s1 = current_s->data[idx0 + 1];
    float sample_float = (float)s0 * (1.0f - frac) + (float)s1 * frac;

    // --- Bitcrush/LoFi ---
    float norm_sample = sample_float / 32768.0f;
    float crushed = round(norm_sample * ((1 << bitcrush_bits) - 1)) / ((1 << bitcrush_bits) - 1);

    // --- Tape saturation (soft clipping) ---
    float lofi_sample = tanhf(crushed * SATURATION_DRIVE_TAPE);

    // --- High-cut (low‑pass) ---
    lofi_sample = LPF_ALPHA_TAPE * lofi_sample + (1.0f - LPF_ALPHA_TAPE) * lpf_state_tape;
    lpf_state_tape = lofi_sample;

    // --- Tape hiss ---
    tape_noise_seed = (tape_noise_seed * 1103515245 + 12345);
    float hiss = ((float)((tape_noise_seed >> 16) & 0x7FFF) / 16384.0f - 1.0f) * HISS_LEVEL_TAPE;
    lofi_sample += hiss;

    // --- PWM Output ---
    float output_sample = lofi_sample;
    uint16_t pwm_val = (uint16_t)((output_sample + 1.0f) * 0.5f * PWM_FS);
    pwm_val = max((uint16_t)0, min((uint16_t)PWM_FS, pwm_val));
    pwm_set_chan_level(slice_num, PWM_CHAN_B, pwm_val);

    // --- Playback with Wow/Flutter ---
    playback_fidx += 1.0f + wow_lfo;
}

// --- Trigger Handler ---
void onTrig() {
    unsigned long current_time = millis();
    if (current_time - last_trigger_time < debounce_delay) {
        return;
    }
    last_trigger_time = current_time;

    if (NUM_SAMPLES == 0) return;

    playback_fidx = 0.0f;
    playing = true;
    digitalWrite(LED_PIN, HIGH);
}

// --- Setup ---
void setup() {
    analogReadResolution(10);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);

    uint slice_num = pwm_gpio_to_slice_num(PWM_OUTPUT_PIN);
    gpio_set_function(PWM_OUTPUT_PIN, GPIO_FUNC_PWM);
    pwm_set_clkdiv_int_frac(slice_num, 4, 0);
    pwm_set_wrap(slice_num, (uint16_t)PWM_FS);
    pwm_set_chan_level(slice_num, PWM_CHAN_B, (uint16_t)PWM_MID);
    pwm_set_enabled(slice_num, true);
    pwm_clear_irq(slice_num);
    pwm_set_irq_enabled(slice_num, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    pinMode(TRIGGER_INPUT_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(TRIGGER_INPUT_PIN), onTrig, RISING);
}

// --- Main Loop ---
void loop() {
    // 1) Button for sample selection (debounced)
    int current_button_state = digitalRead(BUTTON_PIN);
    if (current_button_state == LOW && last_button_state == HIGH) {
        if (millis() - last_button_press_time > 50) {
            current_sample_idx = (current_sample_idx + 1) % NUM_SAMPLES;
            last_button_press_time = millis();
        }
    }
    last_button_state = current_button_state;

    // 2) POT1: Bitcrush/LoFi (inverted: left = clean, right = LoFi)
    uint32_t lofi_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
        lofi_adc_sum += analogRead(POT_LOFI_PIN);
    }
    float lofi_pot = (lofi_adc_sum / 4.0f) / 1023.0f;
    bitcrush_bits = 12 - (int)(lofi_pot * 10.0f); // 12–2 Bit
    if (bitcrush_bits < 2) bitcrush_bits = 2;
    if (bitcrush_bits > 12) bitcrush_bits = 12;

    // 3) POT2: Tape crash/glitch (dropout/stutter, max ~15%)
    uint32_t crash_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
        crash_adc_sum += analogRead(POT_CRASH_PIN);
    }
    float crash_pot = (crash_adc_sum / 4.0f) / 1023.0f;
    // Mapping: 0–0.15, more granular at low values
    crash_chance = pow(crash_pot, 1.5f) * 0.15f; // exponential for finer low-end control

    // 4) POT3: Wow/Flutter intensity (max ~8%)
    uint32_t wow_adc_sum = 0;
    for(int i = 0; i < 4; i++) {
        wow_adc_sum += analogRead(POT_WOW_PIN);
    }
    float wow_pot = (wow_adc_sum / 4.0f) / 1023.0f;
    wow_depth = wow_pot * 0.08f; // 0–8% pitch wobble

    delay(10);
}