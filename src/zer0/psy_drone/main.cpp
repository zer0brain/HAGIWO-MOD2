/*
HAGIWO MOD2

zer0 Psy Drone v1.0
Four detuned oscillators with simple low-pass filtering for evolving drone textures.

-- Pin assignment --
POT1   A1     Base frequency (FLIP: A3)
POT2   A2     Detune amount
POT3   A3     Filter cutoff (and CV on same pin)
IN1    GPIO26 Drone on/off
OUT    DAC0   Audio output
BUTTON GPIO1  Bank select
LED    GPIO25 Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>
#include <math.h>

// Fixed connector pins (never change)
#define OUT_PIN 0          // DAC - Audio output
#define BUTTON_PIN 1       // D1 - Bank selection button
#define LED_PIN 25         // D10 - Activity LED
#define GATE1_PIN 26       // A0 - Drone on/off (fixed)

// Potentiometer pins (flip based on orientation)
#ifdef FLIP
  // Flipped pot layout
  #define POT1_PIN 29      // A3 - Base frequency
  #define POT2_PIN 28      // A2 - Detune spread  
  #define POT3_PIN 27      // A1 - Filter frequency (and CV)
#else
  // Normal pot layout (default)
  #define POT1_PIN 27      // A1 - Base frequency
  #define POT2_PIN 28      // A2 - Detune spread
  #define POT3_PIN 29      // A3 - Filter frequency (and CV)
#endif

// Audio Configuration
const float SAMPLE_RATE = 44100.0;
const int PWM_RESOLUTION = 1024;
const int PWM_MID = PWM_RESOLUTION / 2;

// Single Layer Psychedelic Drone
struct PsyDrone {
  float osc_phases[4];
  float base_freq;
  float detune_spread;
  float filter_freq;
  float filter_lp;
  float mod_phase;
  bool drone_active;
  bool mod_active;
  uint8_t bank_mode;
};

PsyDrone drone;
bool button_state = false;
bool last_button_state = false;
unsigned long last_button_time = 0;

void setup() {
  pinMode(POT1_PIN, INPUT);
  pinMode(POT2_PIN, INPUT);
  pinMode(POT3_PIN, INPUT);
  pinMode(GATE1_PIN, INPUT);
  // No second gate on HAGIWO standard; using only GATE1
  pinMode(OUT_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  
  analogWriteFreq(SAMPLE_RATE);
  analogWriteRange(PWM_RESOLUTION);
  
  for (int i = 0; i < 4; i++) {
    drone.osc_phases[i] = 0.0;
  }
  drone.base_freq = 110.0;  // A2
  drone.detune_spread = 5.0;
  drone.filter_freq = 1000.0;
  drone.filter_lp = 0.0;
  drone.mod_phase = 0.0;
  drone.drone_active = false;
  drone.mod_active = false;
  drone.bank_mode = 0;
}

void loop() {
  uint16_t pot1_val = analogRead(POT1_PIN);
  uint16_t pot2_val = analogRead(POT2_PIN);
  uint16_t pot3_val = analogRead(POT3_PIN);
  pot3_val = 4095 - pot3_val;  // Invert CV
  
  bool gate1 = digitalRead(GATE1_PIN);
  bool gate2 = false; // Not used on this platform
  
  bool current_button = !digitalRead(BUTTON_PIN);
  if (current_button && !last_button_state && (millis() - last_button_time > 50)) {
    drone.bank_mode = (drone.bank_mode + 1) % 4;
    last_button_time = millis();
  }
  last_button_state = current_button;
  
  drone.drone_active = gate1;
  drone.mod_active = gate2;
  
  // Update parameters
  drone.base_freq = 55.0 + (pot1_val / 4095.0) * 440.0;  // 55Hz to 495Hz
  drone.detune_spread = (pot2_val / 4095.0) * 20.0;  // 0 to 20Hz spread
  drone.filter_freq = 200.0 + (pot3_val / 4095.0) * 3800.0;  // 200Hz to 4000Hz
  
  if (drone.drone_active) {
    // Modulation LFO
    drone.mod_phase += (2.0 * PI * 0.3) / SAMPLE_RATE;  // 0.3Hz LFO
    if (drone.mod_phase >= 2.0 * PI) drone.mod_phase -= 2.0 * PI;
    
    float mod_amount = drone.mod_active ? sin(drone.mod_phase) * 0.5 : 0.0;
    
    // Generate 4 detuned oscillators
    float mixed_output = 0.0;
    
    for (int i = 0; i < 4; i++) {
      // Calculate detuned frequency for each oscillator
      float detune_factor;
      switch (drone.bank_mode) {
        case 0: // Harmonic - musical intervals
          detune_factor = 1.0 + (i * 0.5);  // Octaves and fifths
          break;
        case 1: // Linear detune
          detune_factor = 1.0 + (i * drone.detune_spread / drone.base_freq);
          break;
        case 2: // Clustered - close detuning
          detune_factor = 1.0 + ((i - 2.0) * drone.detune_spread * 0.1 / drone.base_freq);
          break;
        case 3: // Chaotic - random-ish detuning
          detune_factor = 1.0 + (sin(i * 1.7) * drone.detune_spread / drone.base_freq);
          break;
      }
      
      float osc_freq = drone.base_freq * detune_factor;
      
      // Apply modulation
      if (drone.mod_active) {
        osc_freq += mod_amount * drone.detune_spread * (i + 1);
      }
      
      // Update oscillator phase
      drone.osc_phases[i] += (osc_freq * 2.0 * PI) / SAMPLE_RATE;
      if (drone.osc_phases[i] >= 2.0 * PI) drone.osc_phases[i] -= 2.0 * PI;
      
      // Generate waveform (mix of sine and saw for texture)
      float sine_wave = sin(drone.osc_phases[i]);
      float saw_wave = (drone.osc_phases[i] / PI) - 1.0;
      
      float mixed_wave;
      switch (drone.bank_mode) {
        case 0: // Pure sine
          mixed_wave = sine_wave;
          break;
        case 1: // Sine + saw
          mixed_wave = sine_wave * 0.7 + saw_wave * 0.3;
          break;
        case 2: // More saw
          mixed_wave = sine_wave * 0.3 + saw_wave * 0.7;
          break;
        case 3: // Distorted
          mixed_wave = tanh(sine_wave * 2.0) * 0.7;
          break;
      }
      
      mixed_output += mixed_wave * 0.25;  // Mix 4 oscillators
    }
    
    // Low-pass filter
    float filter_coeff = exp(-2.0 * PI * drone.filter_freq / SAMPLE_RATE);
    drone.filter_lp = drone.filter_lp * filter_coeff + mixed_output * (1.0 - filter_coeff);
    
    // Output filtered signal
    int pwm_val = PWM_MID + (int)(drone.filter_lp * PWM_MID * 0.6);
    if (pwm_val < 0) pwm_val = 0;
    if (pwm_val >= PWM_RESOLUTION) pwm_val = PWM_RESOLUTION - 1;
    
    analogWrite(OUT_PIN, pwm_val);
    digitalWrite(LED_PIN, HIGH);
  } else {
    analogWrite(OUT_PIN, PWM_MID);
    digitalWrite(LED_PIN, LOW);
  }
  
  delayMicroseconds(22);
}
