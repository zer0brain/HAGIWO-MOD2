/*
HAGIWO MOD2

zer0 Death Scream v1.0
Granular sample mangler for two embedded “scream” samples; gritty and chaotic.

-- Pin assignment --
POT1   A0     Grain size
POT2   A1     Decay time (10ms to sample length)
POT3   A2     Position (scan through sample)
IN1    GPIO7  Trigger
OUT    GPIO1  Audio PWM output
BUTTON GPIO6  Sample select
LED    GPIO5  Activity
EEPROM N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

[History]
v1.0  - Initial release
*/

#include <Arduino.h>

// Include the death scream samples directly
#include "scream2.C"
#include "scream3.C"

// HAGIWO MOD2 Pin assignment
#define OUT_PIN     1
#define GATE1_PIN   7
#define BUTTON_PIN  6
#define LED_PIN     5
#define POT1_PIN    A0  // Grain Size (creepy factor)
#define POT2_PIN    A1  // Decay Time (10ms to sample length)  
#define POT3_CV_PIN A2  // Scream Position (hunt through sample)

volatile bool triggered = false;
volatile bool playing = false;  
bool last_button = false;
bool last_trigger = false;  
unsigned long last_button_time = 0;
int current_sample = 0;

// Granular creepy variables
unsigned int grain_pos = 0;
unsigned int sample_pos = 0;
unsigned int grain_size = 1000;
unsigned int grain_speed = 1;
float creepy_factor = 1.0f;
bool grain_reverse = false;
const unsigned char* current_sample_data = nullptr;
unsigned long last_sample_time = 0;
uint32_t chaos_seed = 0xDEAD;

// Performance optimization - cache poti values
unsigned long last_poti_read = 0;
float cached_decay_time = 1000.0f;
unsigned int cached_grain_size = 1000;
float cached_position_hunt = 0.0f;

// Decay variables for creepy grain level modulation
unsigned long decay_start_time = 0;
float decay_duration = 5000.0f;  // Base decay time in ms
float decay_level = 1.0f;        // Current decay level (1.0 = full, 0.0 = silent)
float decay_randomness = 0.0f;   // Random variation for creepy effect

void setup() {
  pinMode(OUT_PIN, OUTPUT);
  pinMode(GATE1_PIN, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);
  analogWriteFreq(22050);
  analogWriteRange(1024);
  
  // No interrupt - use polling instead
}

// Fast chaos noise for creepy effects
float creepy_noise() {
  chaos_seed = chaos_seed * 1664525 + 1013904223;
  return ((chaos_seed >> 16) & 0xFFFF) / 32768.0f - 1.0f;
}

void loop() {
  // Sample selection button
  bool btn = !digitalRead(BUTTON_PIN);
  if (btn && !last_button && millis() - last_button_time > 200) {
    current_sample = (current_sample + 1) % 2;
    last_button_time = millis();
  }
  last_button = btn;

  // Trigger detection - start creepy scream
  bool current_trigger = digitalRead(GATE1_PIN);
  if (current_trigger && !last_trigger) {
    triggered = true;
  }
  last_trigger = current_trigger;

  // Start creepy granular scream
  if (triggered) {
    triggered = false;
    playing = true;
    grain_pos = 0;
    sample_pos = 0;
    current_sample_data = (current_sample == 0) ? scream2 : scream3;
    last_sample_time = micros();
    
    // Initialize decay for creepy grain level modulation
    decay_start_time = millis();
    
    // Decay duration will be controlled by POT1 during playback
    // Range: 10ms to sample duration (calculated in playback loop)
    
    decay_level = 1.0f;
    decay_randomness = 0.0f;
    
    digitalWrite(LED_PIN, HIGH);
  }

  // Continue creepy granular playback
  if (playing) {
    // Read poti values only every 5ms for performance
    unsigned long current_time = millis();
    if (current_time - last_poti_read >= 5) {
      uint16_t pot1_raw = analogRead(POT1_PIN);
      uint16_t pot2_raw = analogRead(POT2_PIN);
      uint16_t pot3_raw = analogRead(POT3_CV_PIN);
      
      // Determine ADC range
      uint16_t adc_max = 1023;
      if (pot1_raw > 1023 || pot2_raw > 1023 || pot3_raw > 1023) {
        adc_max = 4095;
      }
      
      // Calculate sample-dependent parameters
      unsigned int original_length = (current_sample == 0) ? scream2_len : scream3_len;
      float max_decay_time = (original_length / 22050.0f) * 1000.0f;  // Sample duration in ms
      
      // Cache calculated values
      cached_grain_size = 50 + (pot1_raw * 2000) / adc_max;                                  // 50-2050 samples
      cached_decay_time = 10.0f + (pot2_raw * (max_decay_time - 10.0f)) / adc_max;          // 10ms to sample length
      cached_position_hunt = pot3_raw / (float)adc_max;                                      // 0.0 to 1.0
      
      last_poti_read = current_time;
    }
    
    // Use cached values for performance
    grain_size = cached_grain_size;
    
    // Calculate linear decay over time
    unsigned long elapsed_time = current_time - decay_start_time;
    float base_decay = 1.0f - (elapsed_time / cached_decay_time);
    base_decay = constrain(base_decay, 0.0f, 1.0f);
    
    // Add creepy randomness to decay
    if (grain_pos % 50 == 0) {
      decay_randomness = creepy_noise() * 0.15f;
    }
    
    // Combine linear decay with creepy variation
    decay_level = base_decay * (1.0f + decay_randomness);
    decay_level = constrain(decay_level, 0.0f, 1.0f);
    
    // Creepy position jumping
    unsigned int original_length = (current_sample == 0) ? scream2_len : scream3_len;
    unsigned int hunt_pos = (unsigned int)(original_length * cached_position_hunt * 0.8f);
    
    // Play sample with granular creepy effects - optimized timing
    if (micros() - last_sample_time >= 40) {  // Slightly faster: ~25kHz
      // Calculate grain position with chaos
      if (grain_pos >= grain_size) {
        grain_pos = 0;
        
        // Less frequent random jumping to reduce stutter
        if (creepy_noise() > 0.6f) {  // Reduced from 0.3f to 0.6f
          sample_pos = hunt_pos + (unsigned int)(creepy_noise() * 300.0f);  // Reduced range
          grain_reverse = creepy_noise() > 0.2f;  // Less reverse
        }
        
        // Clamp position
        if (sample_pos >= original_length - grain_size) {
          sample_pos = original_length - grain_size - 1;
        }
      }
      
      // Get sample with direction
      unsigned int read_pos;
      if (grain_reverse) {
        read_pos = sample_pos + grain_size - grain_pos;
      } else {
        read_pos = sample_pos + grain_pos;
      }
      
      if (read_pos < original_length) {
        int val = current_sample_data[read_pos] - 128;
        
        // Creepy distortion with chaos
        float chaos = creepy_noise() * 0.2f;
        float driven = val * (2.0f + chaos);
        
        // Brutal asymmetric clipping
        if (driven > 127.0f) driven = 127.0f - (driven - 127.0f) * 0.05f;
        if (driven < -128.0f) driven = -128.0f + (driven + 128.0f) * 0.1f;
        
        // Output with grain envelope + decay modulation (optimized)
        float grain_env = 1.0f;
        unsigned int fade_samples = min(grain_size / 10, 50);  // Dynamic fade based on grain size
        if (grain_pos < fade_samples) grain_env = grain_pos / (float)fade_samples;
        if (grain_pos > grain_size - fade_samples) grain_env = (grain_size - grain_pos) / (float)fade_samples;
        
        // Apply creepy decay to grain level (not just volume)
        grain_env *= decay_level;
        
        // Additional creepy modulation when decay is low
        if (decay_level < 0.5f) {
          float creepy_mod = 1.0f + creepy_noise() * (1.0f - decay_level) * 0.3f;
          grain_env *= creepy_mod;
        }
        
        int pwm = 512 + (int)(driven * grain_env * 3.0f);
        pwm = constrain(pwm, 0, 1023);
        
        analogWrite(OUT_PIN, pwm);
      }
      
      grain_pos += grain_speed;
      sample_pos += grain_speed;
      last_sample_time = micros();
      
      // Stop when decay reaches very low level or sample end
      if (decay_level < 0.05f || sample_pos > original_length * 0.8f) {
        playing = false;
        digitalWrite(LED_PIN, LOW);
      }
    }
  }
}
